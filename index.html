<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mindful Tap Meditation Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }

        /* Apply button styling to match the previous div structure, ensuring it fills the flex area */
        .side-tap-area {
            transition: background-color 0.2s, box-shadow 0.2s;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            /* Make button fill its flex container */
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background-color: transparent; /* Reset default button background */
            padding: 1rem;
        }

        .side-tap-area.expected {
            /* Highlight when the expected side is active */
            box-shadow: 0 0 20px 5px rgba(59, 130, 246, 0.7); /* Blue glow */
        }

        .side-tap-area:active {
            filter: brightness(0.9);
            transform: scale(0.99);
        }

        /* Ensure the base background color is set on the button */
        #left-area-btn { background-color: #e5e7eb; } /* gray-200 */
        #right-area-btn { background-color: #e5e7eb; } /* gray-200 */

        .beeping-bg {
            animation: pulse-bg 1s infinite alternate;
        }
        @keyframes pulse-bg {
            0% { background-color: #fca5a5; } /* Red-300 */
            100% { background-color: #ef4444; } /* Red-500 */
        }
    </style>

    <!-- 1. STATE & PERSISTENCE -->
    <script>
        // --- Game Constants and State ---
        const DTN_DEFAULT = 5;
        const DEFAULT_INACTIVITY_MS = 30000; // 30 seconds default
        const SESSION_DURATION_DEFAULT_MINUTES = 10;
        const LOCAL_STORAGE_KEY = 'mindfulTapSettings'; // Key for localStorage

        const state = {
            dtn: DTN_DEFAULT,
            inactivityDurationMs: DEFAULT_INACTIVITY_MS,
            sessionDurationMinutes: SESSION_DURATION_DEFAULT_MINUTES,
            hideStatus: false,
            isVibrationEnabled: false,
            gameState: 'idle', // 'idle', 'running', 'paused', 'complete'
            breathCount: 0, // 1 to DTN
            currentStreak: 0,
            longestStreak: 0,
            expectedSide: 'right', // 'left' or 'right'
            expectedTapType: 'single', // 'single' or 'double' (denoting a DTN sequence)
            cycleStartSide: 'right', // The side the current cycle started on (B1)
            tapTimer: null, // Timer for the focus window (inactivity reset)
            isBeeping: false,
            isAwaitingSecondTap: false, // Tracks if the first tap of the DTN double sequence has occurred.

            // Timers for display and session management
            timeRemaining: DEFAULT_INACTIVITY_MS / 1000, // Breath window seconds remaining
            countdownInterval: null, // Interval for the breath window countdown
            sessionTimer: null, // Timeout for total session duration
            sessionTimeRemainingSeconds: 0,
            sessionCountdownInterval: null, // Interval for the session countdown
        };

        // --- Local Storage Persistence ---
        function loadSettings() {
            const storedSettings = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (storedSettings) {
                try {
                    const data = JSON.parse(storedSettings);
                    state.dtn = data.dtn || DTN_DEFAULT;
                    state.inactivityDurationMs = data.inactivityDurationMs || DEFAULT_INACTIVITY_MS;
                    state.sessionDurationMinutes = data.sessionDurationMinutes || SESSION_DURATION_DEFAULT_MINUTES;
                    state.longestStreak = data.longestStreak || 0;
                    state.hideStatus = data.hideStatus !== undefined ? data.hideStatus : false;
                    state.isVibrationEnabled = data.isVibrationEnabled !== undefined ? data.isVibrationEnabled : false;
                } catch (e) {
                    console.error("Error parsing settings from localStorage:", e);
                    // Fallback to defaults
                }
            }

            // Update input fields (relies on DOM being ready, handled in window.onload)
            if (document.readyState === 'complete') {
                document.getElementById('dtn-input').value = state.dtn;
                document.getElementById('duration-input').value = state.inactivityDurationMs / 1000;
                document.getElementById('session-duration-input').value = state.sessionDurationMinutes;
                document.getElementById('hide-status-input').checked = state.hideStatus;
                document.getElementById('vibration-input').checked = state.isVibrationEnabled;
            }
        }

        function saveSettings(dtn, inactivityDurationMs, sessionDurationMinutes, longestStreak, hideStatus, isVibrationEnabled) {
            state.longestStreak = longestStreak; // Update state before saving
            const settings = {
                dtn: dtn,
                inactivityDurationMs: inactivityDurationMs,
                sessionDurationMinutes: sessionDurationMinutes,
                longestStreak: longestStreak,
                hideStatus: hideStatus,
                isVibrationEnabled: isVibrationEnabled,
            };
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(settings));
        }
    </script>

    <!-- 2. AUDIO UTILITIES -->
    <script>
        // --- Audio Context for Focus Reminder (Beep) and Tones ---
        let audioContext;
        let oscillator;
        let gainNode;

        // Vibration Function
        function triggerVibration(pattern) {
            if (state.isVibrationEnabled && 'vibrate' in navigator) {
                navigator.vibrate(pattern);
            }
        }

        function startBeeping() {
            if (state.isBeeping) return;
            state.isBeeping = true;

            // VIBRATION INTEGRATION (Long pattern for inactivity)
            triggerVibration([500, 500, 500]);

            try {
                audioContext = audioContext || new (window.AudioContext || window.webkitAudioContext)();
                oscillator = audioContext.createOscillator();
                gainNode = audioContext.createGain();

                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4 note
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Start beeping pattern (simple on/off)
                const beepDuration = 0.2; // seconds
                const interval = 0.5; // seconds

                let time = audioContext.currentTime;

                // Create the repeating pattern
                for (let i = 0; i < 20; i++) { // Repeat 20 times, enough to get focus back
                    gainNode.gain.setValueAtTime(0.5, time + i * interval);
                    gainNode.gain.setValueAtTime(0, time + i * interval + beepDuration);
                }

                oscillator.start(time);
                oscillator.stop(time + 20 * interval);

                oscillator.onended = () => {
                    if (state.isBeeping) {
                        // Restart beeping if still required
                        startBeeping();
                    }
                };

            } catch (e) {
                console.warn("Audio API not supported or failed to start:", e);
            }
        }

        function stopBeeping() {
            if (!state.isBeeping) return;
            state.isBeeping = false;
            // Stop vibration immediately
            triggerVibration(0);

            if (oscillator) {
                try {
                    // Smoothly fade out the gain to avoid click sound
                    gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.1);
                    oscillator.stop(audioContext.currentTime + 0.1);
                } catch (e) {
                    console.error("Error stopping audio:", e);
                }
            }
        }

        function playMistakeTone() {
            // VIBRATION INTEGRATION (Short pulse for mistake)
            triggerVibration(200);

            try {
                audioContext = audioContext || new (window.AudioContext || window.webkitAudioContext)();
                const tone = audioContext.createOscillator();
                const gain = audioContext.createGain();

                tone.type = 'sawtooth';
                tone.frequency.setValueAtTime(120, audioContext.currentTime); // Low frequency tone
                gain.gain.setValueAtTime(0.3, audioContext.currentTime); // Volume

                tone.connect(gain);
                gain.connect(audioContext.destination);

                tone.start(audioContext.currentTime);
                tone.stop(audioContext.currentTime + 0.15); // Short duration (150ms)

            } catch (e) {
                console.warn("Audio API not supported or failed to play mistake tone:", e);
            }
        }

        function playGong() {
            try {
                audioContext = audioContext || new (window.AudioContext || window.webkitAudioContext)();

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.type = 'sine';

                // Low frequency start for the bell/gong sound
                oscillator.frequency.setValueAtTime(110, audioContext.currentTime);

                // Volume envelope for a gentle strike and fade out
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.8, audioContext.currentTime + 0.05); // Quick rise to strike
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 3); // Slow, gentle fade over 3s

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 3); // Stop after 3 seconds

            } catch (e) {
                console.warn("Audio API not supported or failed to play gong tone:", e);
            }
        }
    </script>

    <!-- 3. GAME CORE LOGIC & UI UPDATES -->
    <script>
        // --- Utility Functions ---
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const paddedSeconds = String(seconds).padStart(2, '0');
            return `${minutes}:${paddedSeconds}`;
        }

        // --- Game Logic Functions ---
        function updateUI(statusOverride = null) {
            const leftArea = document.getElementById('left-area-btn');
            const rightArea = document.getElementById('right-area-btn');
            const statusDisplay = document.getElementById('status-display');
            const streakDisplay = document.getElementById('streak-display');
            const longestStreakDisplay = document.getElementById('longest-streak-display');
            const startBtn = document.getElementById('start-btn');
            const stopBtn = document.getElementById('stop-btn');
            const pauseBtn = document.getElementById('pause-btn'); // NEW
            const modalDtnDisplay = document.getElementById('modal-dtn-display');
            const timeRemainingDisplay = document.getElementById('time-remaining-display');
            const sessionTimeDisplay = document.getElementById('session-time-display');

            // 1. Game State and Buttons
            let currentStatus = `Status: ${state.gameState.toUpperCase()}`;
            if (statusOverride === 'complete') {
                currentStatus = '<span class="text-green-600 font-bold">Session Complete!</span>';
            }

            const isGameActive = state.gameState === 'running' || state.gameState === 'paused';
            const isRunning = state.gameState === 'running';
            const isPaused = state.gameState === 'paused';
            const isIdle = state.gameState === 'idle' || state.gameState === 'complete';


            // Apply visibility setting: Hide only when active AND setting is enabled
            if (state.hideStatus && isRunning) {
                statusDisplay.classList.add('hidden');
            } else {
                statusDisplay.classList.remove('hidden');
                statusDisplay.innerHTML = currentStatus; // Set the generic status if not hidden
            }

            // Button visibility and text logic
            stopBtn.disabled = isIdle; // Stop is available in Running or Paused

            if (isIdle) {
                startBtn.textContent = 'Start';
                startBtn.classList.remove('hidden');
                pauseBtn.classList.add('hidden');
            } else if (isRunning) {
                startBtn.classList.add('hidden'); // Hide Start button
                pauseBtn.textContent = 'Pause';
                pauseBtn.classList.remove('hidden'); // Show Pause button
            } else if (isPaused) {
                startBtn.textContent = 'Resume';
                startBtn.classList.remove('hidden'); // Show Resume button
                pauseBtn.classList.add('hidden'); // Hide Pause button
            }

            startBtn.disabled = isRunning; // Start button is disabled only if running (prevents double clicking)

            // 2. Tap Area Highlight
            leftArea.classList.remove('expected');
            rightArea.classList.remove('expected');

            if (isRunning) {
                let tapText = (state.isAwaitingSecondTap ? 'Second Tap' : state.expectedTapType === 'double' ? 'First Tap (DTN)' : 'Single Tap');

                // Highlight single expected side
                const expectedArea = document.getElementById(`${state.expectedSide}-area-btn`);
                expectedArea.classList.add('expected');

                if (!state.hideStatus) {
                    let breathStatus = `Breath ${state.breathCount}/${state.dtn}`;
                    if (state.expectedTapType === 'double' && state.isAwaitingSecondTap) {
                        // Display the full breath count for the full sequence
                        breathStatus = `Breath ${state.dtn}/${state.dtn}`;
                    }

                    statusDisplay.innerHTML = `${breathStatus} | <span class="text-blue-600">${state.expectedSide.toUpperCase()} (${tapText})</span>`;
                }
            }

            // 3. Beeping/Focus Reset Visual
            const gameArea = document.getElementById('game-area');
            gameArea.classList.toggle('beeping-bg', state.isBeeping);

            // 4. Streaks
            streakDisplay.textContent = `Streak: ${state.currentStreak}`;
            longestStreakDisplay.textContent = `Longest: ${state.longestStreak}`;

            // 5. Timer Displays
            if (isGameActive) {
                timeRemainingDisplay.textContent = `Breath Window: ${Math.max(0, state.timeRemaining)}s`;
                sessionTimeDisplay.textContent = `Session Time: ${formatTime(state.sessionTimeRemainingSeconds)}`;
            } else {
                timeRemainingDisplay.textContent = 'Breath Window: --s';
                sessionTimeDisplay.textContent = 'Session Time: --:--';
            }

            // 6. Modal Input Updates
            if (modalDtnDisplay) {
                modalDtnDisplay.textContent = state.dtn;
            }
        }

        // Stops the session, resets all timers, and transitions to idle/complete state.
        function stopMeditation(trigger = 'manual') {
            stopBeeping();

            // Clear all timers
            clearTimeout(state.tapTimer);
            clearInterval(state.countdownInterval);
            clearTimeout(state.sessionTimer);
            clearInterval(state.sessionCountdownInterval);

            state.tapTimer = null;
            state.countdownInterval = null;
            state.sessionTimer = null;
            state.sessionCountdownInterval = null;

            const finalStreak = state.currentStreak;

            // Play gong if session completed automatically
            if (trigger === 'complete') {
                playGong();
            }

            // Save streak if it's a record
            if (finalStreak > state.longestStreak) {
                saveSettings(state.dtn, state.inactivityDurationMs, state.sessionDurationMinutes, finalStreak, state.hideStatus, state.isVibrationEnabled);
            }

            // Reset streak and breath tracking
            state.currentStreak = 0;
            state.breathCount = 0; // Ensures restart goes to B1
            state.expectedSide = 'right';
            state.expectedTapType = 'single'; // Reset tap type
            state.cycleStartSide = 'right';
            state.isAwaitingSecondTap = false; // Reset DTN sequence flag

            // Set final game state and update UI
            state.gameState = 'idle';
            updateUI(trigger === 'complete' ? 'complete' : null);
        }

        // NEW: Pause Meditation Function
        function pauseMeditation() {
            if (state.gameState !== 'running') return;

            // 1. Stop all intervals/timeouts
            clearTimeout(state.tapTimer);
            clearInterval(state.countdownInterval);
            clearInterval(state.sessionCountdownInterval);

            // 2. Clear the main session timer
            clearTimeout(state.sessionTimer);

            state.tapTimer = null;
            state.countdownInterval = null;
            state.sessionTimer = null;

            // 3. Update game state and UI
            state.gameState = 'paused';
            updateUI();
        }

        // NEW: Resume Meditation Function
        function resumeMeditation() {
            if (state.gameState !== 'paused') return;

            state.gameState = 'running';

            // 1. Restart breath window timer from scratch
            startTapTimer();

            // 2. Restart the session timer from the time we paused at
            startSessionTimer(state.sessionTimeRemainingSeconds);

            updateUI();
        }


        /**
         * Resets the breath counter/streak due to mistake or inactivity, but keeps session running.
         * 'mistake': input error, plays tone.
         * 'inactivity': timeout, starts beeping.
         * 'start': manual start, no sound.
         */
        function resetFocus(trigger) {
            console.log(`Resetting focus due to: ${trigger}`);

            // Play mistake tone if reset was due to an input error
            if (trigger === 'mistake') {
                playMistakeTone();
            }

            // Save current streak if it's the longest
            if (state.currentStreak > state.longestStreak) {
                saveSettings(state.dtn, state.inactivityDurationMs, state.sessionDurationMinutes, state.currentStreak, state.hideStatus, state.isVibrationEnabled);
            }

            // Reset breath/streak counters
            state.currentStreak = 0;
            state.breathCount = 1; // Starts on breath 1
            state.cycleStartSide = 'right';
            state.expectedSide = 'right';
            state.expectedTapType = 'single'; // B1 is always a single tap
            state.isAwaitingSecondTap = false; // Reset DTN sequence flag

            if (trigger === 'inactivity') {
                state.gameState = 'paused';
                startBeeping();
            } else { // Handles 'mistake' and 'start'
                state.gameState = 'running';
                startTapTimer();
            }

            updateUI();
        }

        // Starts or restarts the breath focus timer (inactivity reset)
        function startTapTimer() {
            clearTimeout(state.tapTimer);
            clearInterval(state.countdownInterval);

            // 1. Start the inactivity timer using the user-defined duration
            state.tapTimer = setTimeout(() => {
                resetFocus('inactivity');
            }, state.inactivityDurationMs);

            // 2. Start the countdown display
            const durationInSeconds = state.inactivityDurationMs / 1000;
            state.timeRemaining = durationInSeconds;

            state.countdownInterval = setInterval(() => {
                state.timeRemaining = Math.max(0, state.timeRemaining - 1);
                updateUI();

                if (state.timeRemaining <= 0) {
                    clearInterval(state.countdownInterval);
                    state.countdownInterval = null;
                }
            }, 1000);

            updateUI();
        }

        // Starts the main session duration timer (accepts optional initialSeconds for resume)
        function startSessionTimer(initialSeconds = null) {
            clearTimeout(state.sessionTimer);
            clearInterval(state.sessionCountdownInterval);

            // Determine the starting time for the timer
            const secondsToRun = initialSeconds !== null ? initialSeconds : state.sessionDurationMinutes * 60;
            const durationMs = secondsToRun * 1000;

            // Set up the main timer that stops the session
            state.sessionTimer = setTimeout(() => {
                stopMeditation('complete');
            }, durationMs);

            // Set up the display countdown
            state.sessionTimeRemainingSeconds = secondsToRun;
            state.sessionCountdownInterval = setInterval(() => {
                state.sessionTimeRemainingSeconds = Math.max(0, state.sessionTimeRemainingSeconds - 1);
                updateUI();
                if (state.sessionTimeRemainingSeconds <= 0) {
                    clearInterval(state.sessionCountdownInterval);
                    state.sessionCountdownInterval = null;
                }
            }, 1000);
        }

        /**
         * Advances the breath count, streak, and expected side/tap type.
         * Only called when a *breath* (either single tap or successful double-tap sequence) is complete.
         */
        function advanceBreath() {
            state.currentStreak++;

            if (state.expectedTapType === 'double') {
                // DTN double tap sequence just completed (after the second tap).
                // Complete the cycle and flip the side.
                state.breathCount = 1;
                state.cycleStartSide = (state.cycleStartSide === 'right' ? 'left' : 'right');
                state.expectedSide = state.cycleStartSide;
                state.expectedTapType = 'single';
            } else {
                // Regular single tap just completed.
                state.breathCount++;
                state.expectedSide = (state.expectedSide === 'right' ? 'left' : 'right');

                if (state.breathCount === state.dtn) {
                    state.expectedTapType = 'double';
                } else {
                    state.expectedTapType = 'single';
                }
            }

            // Successfully processed, restart breath window timer
            startTapTimer();
        }
    </script>

    <!-- 4. INPUT AND EVENT HANDLERS -->
    <script>
        /**
         * Main input handling function. All inputs (screen click/key press) are considered single taps.
         */
        function handleTap(actualSide) {
            // Prevent interaction if modals are open or game is idle/complete/paused
            if (document.getElementById('instructions-modal').classList.contains('hidden') === false ||
                document.getElementById('settings-modal').classList.contains('hidden') === false ||
                state.gameState === 'paused' || state.gameState === 'idle' || state.gameState === 'complete') {
                return;
            }
            if (state.gameState !== 'running' && state.gameState !== 'paused') return;

            // If in "paused" (beeping) state, only accept correct side to resume
            if (state.isBeeping) {
                if (actualSide === state.expectedSide) {
                    stopBeeping();
                    state.gameState = 'running';
                    startTapTimer();
                }
                return;
            }

            const correctSide = (actualSide === state.expectedSide);

            if (correctSide) {
                if (state.expectedTapType === 'double') {
                    if (state.isAwaitingSecondTap) {
                        // SUCCESSFUL SECOND TAP (completes the DTN sequence)
                        state.isAwaitingSecondTap = false;
                        advanceBreath();
                    } else {
                        // SUCCESSFUL FIRST TAP (starts the DTN sequence)
                        state.isAwaitingSecondTap = true;
                        // Restart timer for the second tap. Streak is advanced only on completion.
                        startTapTimer();
                    }
                } else {
                    // Success on regular single tap.
                    advanceBreath();
                }
            } else {
                // MISTAKE (wrong side)
                resetFocus('mistake');
                state.isAwaitingSecondTap = false; // Reset sequence if failed
            }
        }

        // 1. Screen Tap Logic (Simplest form: one click = one tap)
        function handleScreenTap(event) {
            const actualSide = event.currentTarget.dataset.side;
            handleTap(actualSide);
        }

        // 2. Keyboard Logic (Simplest form: one keydown = one tap)
        function handleKeyDown(event) {
            const key = event.key.toLowerCase();
            let actualSide = null;

            if (key === 'f') { actualSide = 'left'; }
            else if (key === 'j') { actualSide = 'right'; }
            else { return; }

            if (event.repeat) return; // Prevent continuous tapping on key hold
            if (state.gameState !== 'running' && state.gameState !== 'paused') return;

            handleTap(actualSide);
        }

        // 3. Modal Handlers
        function openInstructions() {
            document.getElementById('instructions-modal').classList.remove('hidden');
        }

        function closeInstructions() {
            document.getElementById('instructions-modal').classList.add('hidden');
        }

        function openSettings() {
             // Ensure the inputs reflect the current state before opening
            document.getElementById('dtn-input').value = state.dtn;
            document.getElementById('duration-input').value = state.inactivityDurationMs / 1000;
            document.getElementById('session-duration-input').value = state.sessionDurationMinutes;
            document.getElementById('hide-status-input').checked = state.hideStatus;
            document.getElementById('vibration-input').checked = state.isVibrationEnabled;

            document.getElementById('settings-modal').classList.remove('hidden');
        }

        function closeSettings() {
            document.getElementById('settings-modal').classList.add('hidden');
            // Re-run UI update to ensure values are correctly reflected
            updateUI();
        }

        // --- Initialization ---

        window.onload = function() {
            loadSettings(); // Load settings from localStorage

            // Add event listeners for tap areas (now buttons)
            document.getElementById('left-area-btn').addEventListener('click', handleScreenTap);
            document.getElementById('right-area-btn').addEventListener('click', handleScreenTap);

            // Add event listeners for keyboard input
            document.addEventListener('keydown', handleKeyDown);

            // Add event listeners for modal buttons
            document.getElementById('instructions-btn').addEventListener('click', openInstructions);
            document.getElementById('close-instructions-btn').addEventListener('click', closeInstructions);
            document.getElementById('settings-btn').addEventListener('click', openSettings);
            document.getElementById('close-settings-btn').addEventListener('click', closeSettings);

            // Add event listeners for control buttons
            document.getElementById('start-btn').addEventListener('click', () => {
                if (state.gameState === 'idle' || state.gameState === 'complete') {
                    // Start a fresh meditation session
                    startSessionTimer(); // Start the overall session timer (start fresh)
                    resetFocus('start'); // Start the breath tracking
                } else if (state.gameState === 'paused') {
                    // Resume a paused session
                    resumeMeditation();
                }
            });

            document.getElementById('stop-btn').addEventListener('click', () => stopMeditation('manual'));
            document.getElementById('pause-btn').addEventListener('click', pauseMeditation); // NEW

            document.getElementById('save-settings-btn').addEventListener('click', () => {
                const dtnInput = document.getElementById('dtn-input');
                const durationInput = document.getElementById('duration-input');
                const sessionDurationInput = document.getElementById('session-duration-input');
                const hideStatusInput = document.getElementById('hide-status-input');
                const vibrationInput = document.getElementById('vibration-input');

                const newDTN = parseInt(dtnInput.value, 10);
                const newDurationSec = parseInt(durationInput.value, 10);
                const newDurationMs = newDurationSec * 1000;
                const newSessionDurationMin = parseInt(sessionDurationInput.value, 10);
                const newHideStatus = hideStatusInput.checked;
                const newVibrationEnabled = vibrationInput.checked;

                let isValid = true;
                let feedback = '';

                if (newDTN < 2) {
                    feedback += "DTN must be 2 or greater. ";
                    dtnInput.value = state.dtn;
                    isValid = false;
                }
                if (newDurationSec < 5 || newDurationSec > 180) {
                     feedback += "Breath Window Duration must be between 5 and 180 seconds. ";
                     durationInput.value = state.inactivityDurationMs / 1000;
                     isValid = false;
                }
                if (newSessionDurationMin < 1 || newSessionDurationMin > 180) {
                     feedback += "Session Duration must be between 1 and 180 minutes. ";
                     sessionDurationInput.value = state.sessionDurationMinutes;
                     isValid = false;
                }

                if (isValid) {
                    state.dtn = newDTN;
                    state.inactivityDurationMs = newDurationMs;
                    state.sessionDurationMinutes = newSessionDurationMin;
                    state.hideStatus = newHideStatus;
                    state.isVibrationEnabled = newVibrationEnabled;

                    saveSettings(state.dtn, state.inactivityDurationMs, state.sessionDurationMinutes, state.longestStreak, state.hideStatus, state.isVibrationEnabled);

                    // Show confirmation message
                    const originalText = document.getElementById('save-settings-btn').textContent;
                    document.getElementById('save-settings-btn').textContent = 'Saved!';
                    setTimeout(() => {
                        document.getElementById('save-settings-btn').textContent = originalText;
                        closeSettings(); // Close modal after saving
                    }, 1000);

                    // If game is running, restart breath timer with new duration, but session timer continues unless reset.
                    if (state.gameState === 'running' || state.gameState === 'paused') {
                        startTapTimer();
                    }
                    updateUI();

                } else {
                    console.error("Settings validation failed:", feedback);
                }
            });


            // Initial UI setup
            updateUI();
        };
    </script>
</head>
<body class="bg-gray-50 min-h-screen flex flex-col items-center p-4">

    <!-- Header -->
    <header class="w-full max-w-4xl text-center mb-8">
        <h1 class="text-3xl font-bold text-gray-800 mb-2">Mindful Tap: Breath Focus Game</h1>
        <p class="text-sm text-gray-600 mb-4">
            A tool to anchor your mind to your breath. Observe your breath, then tap the required side.
        </p>
    </header>

    <!-- Game Status and Controls -->
    <div class="w-full max-w-4xl bg-white p-6 rounded-lg shadow-xl mb-6 flex flex-col md:flex-row justify-between items-center space-y-4 md:space-y-0">
        <div id="status-display" class="text-lg font-semibold text-gray-700">Status: Idle</div>

        <!-- Central display for Streak and Timer -->
        <div class="text-center space-y-1">
            <div id="session-time-display" class="text-xl font-bold text-gray-800">Session Time: --:--</div>
            <div id="time-remaining-display" class="text-sm text-gray-600">Breath Window: --s</div>
            <div id="streak-display" class="text-2xl font-extrabold text-indigo-600">Streak: 0</div>
            <div id="longest-streak-display" class="text-sm text-gray-500">Longest: 0</div>
        </div>

        <div class="flex space-x-4">
            <button id="settings-btn" class="px-4 py-3 bg-blue-500 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-blue-600 transition duration-200 transform hover:scale-105">
                Settings
            </button>
            <button id="instructions-btn" class="px-4 py-3 bg-gray-500 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-gray-600 transition duration-200 transform hover:scale-105">
                ? Instructions
            </button>

            <!-- NEW Pause Button -->
            <button id="pause-btn" class="px-8 py-3 bg-yellow-600 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-yellow-700 transition duration-200 transform hover:scale-105 hidden">
                Pause
            </button>

            <!-- Stop Button -->
            <button id="stop-btn" class="px-8 py-3 bg-red-600 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-red-700 transition duration-200 transform hover:scale-105" disabled>
                Stop
            </button>

            <!-- Start/Resume Button -->
            <button id="start-btn" class="px-8 py-3 bg-green-600 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-green-700 transition duration-200 transform hover:scale-105">
                Start
            </button>
        </div>
    </div>

    <!-- Audio Player (Hidden) -->
    <audio id="audio-player" class="hidden"></audio>

    <!-- Main Tap Area -->
    <main id="game-area" class="w-full max-w-4xl flex flex-col md:flex-row h-96 rounded-xl overflow-hidden shadow-2xl transition duration-500">

        <!-- Left Tap Area Button -->
        <button id="left-area-btn" class="side-tap-area flex-1 border-r md:border-b-0 border-gray-300" data-side="left">
            <div class="text-center">
                <p class="text-3xl font-bold text-gray-800">Left Tap</p>
                <p class="text-xl text-gray-600 mt-1">(Key: F)</p>
            </div>
        </button>

        <!-- Right Tap Area Button -->
        <button id="right-area-btn" class="side-tap-area flex-1" data-side="right">
            <div class="text-center">
                <p class="text-3xl font-bold text-gray-800">Right Tap</p>
                <p class="text-xl text-gray-600 mt-1">(Key: J)</p>
            </div>
        </button>

    </main>

    <!-- Settings Modal Screen -->
    <div id="settings-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-gray-900 bg-opacity-80 p-4 transition-opacity duration-300">
        <div class="bg-white w-full max-w-md p-8 rounded-xl shadow-2xl relative max-h-[90vh] overflow-y-auto">
            <h2 class="text-2xl font-bold text-gray-800 mb-6 border-b pb-2">Game Settings</h2>

            <div class="space-y-6">

                <!-- Session Duration Setting -->
                <div class="flex flex-col space-y-2 bg-gray-50 p-4 rounded-lg">
                    <label for="session-duration-input" class="text-gray-700 font-medium text-lg">Session Duration:</label>
                    <div class="flex items-center space-x-2">
                         <input id="session-duration-input" type="number" value="10" min="1" max="180" class="w-full p-2 border border-gray-300 rounded-md text-center text-lg focus:ring-blue-500 focus:border-blue-500">
                         <span class="text-gray-600 font-medium">minutes</span>
                    </div>
                    <p class="text-sm text-gray-500">The total time the meditation will run (1-180 min).</p>
                </div>

                <!-- Focus Window Duration Setting -->
                <div class="flex flex-col space-y-2 bg-gray-50 p-4 rounded-lg">
                    <label for="duration-input" class="text-gray-700 font-medium text-lg">Focus Window Duration:</label>
                    <div class="flex items-center space-x-2">
                         <input id="duration-input" type="number" value="30" min="5" max="180" class="w-full p-2 border border-gray-300 rounded-md text-center text-lg focus:ring-blue-500 focus:border-blue-500">
                         <span class="text-gray-600 font-medium">seconds</span>
                    </div>
                    <p class="text-sm text-gray-500">Time (in seconds) allowed between taps before focus reset.</p>
                </div>

                <!-- DTN Setting (Now Cycle Length) -->
                <div class="flex flex-col space-y-2 bg-gray-50 p-4 rounded-lg">
                    <label for="dtn-input" class="text-gray-700 font-medium text-lg">Double Tap Number (DTN):</label>
                    <input id="dtn-input" type="number" value="5" min="2" class="w-full p-2 border border-gray-300 rounded-md text-center text-lg focus:ring-blue-500 focus:border-blue-500">
                    <p class="text-sm text-gray-500">The cycle length. The DTN-th breath will require a double tap on the required side, after which the alternating pattern flips.</p>
                </div>

                <!-- Hide Status Setting -->
                <div class="flex flex-col space-y-2 bg-gray-50 p-4 rounded-lg">
                    <label for="hide-status-input" class="text-gray-700 font-medium text-lg flex items-center justify-between">
                        Hide Status Display
                        <input id="hide-status-input" type="checkbox" class="h-6 w-6 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                    </label>
                    <p class="text-sm text-gray-500">Hide the detailed "Status" line during meditation for a cleaner view.</p>
                </div>

                <!-- NEW: Vibration Setting -->
                <div class="flex flex-col space-y-2 bg-gray-50 p-4 rounded-lg">
                    <label for="vibration-input" class="text-gray-700 font-medium text-lg flex items-center justify-between">
                        Enable Vibration Feedback
                        <input id="vibration-input" type="checkbox" class="h-6 w-6 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                    </label>
                    <p class="text-sm text-gray-500">Triggers device vibration for focus resets and mistakes (requires compatible device).</p>
                </div>

            </div>

            <button id="save-settings-btn" class="mt-6 w-full px-4 py-3 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
                Save All Settings
            </button>


            <button id="close-settings-btn" class="absolute top-4 right-4 p-2 text-gray-600 hover:text-gray-800 transition duration-150 rounded-full bg-gray-100 hover:bg-gray-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
    </div>

    <!-- Instructions Modal Screen -->
    <div id="instructions-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-gray-900 bg-opacity-80 p-4 transition-opacity duration-300">
        <div class="bg-white w-full max-w-3xl p-8 rounded-xl shadow-2xl relative max-h-[90vh] overflow-y-auto">
            <h2 class="text-3xl font-bold text-gray-800 mb-6 border-b pb-2">Mindful Tap Instructions</h2>

            <div class="text-gray-700 text-base space-y-4">
                <p>Before starting, take a comfortable position. You may close your eyes if you wish.</p>

                <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                    <h3 class="font-semibold text-lg text-blue-700 mb-2">The Basic Rhythm:</h3>
                    <p class="mb-2">Observe your complete breath cycle (in-breath and out-breath).</p>
                    <ul class="list-disc list-inside space-y-1 ml-4">
                        <li>After each completed breath, tap the screen or press a key.</li>
                        <li>The required tap side alternates: <span class="font-bold text-gray-900">Right (J key)</span> then <span class="font-bold text-gray-900">Left (F key)</span>.</li>
                        <li>The meditation starts with a tap on the <span class="font-bold text-blue-600">Right side</span>.</li>
                    </ul>
                </div>

                <div class="bg-yellow-50 p-4 rounded-lg border border-yellow-200">
                    <h3 class="font-semibold text-lg text-yellow-700 mb-2">Double Tap Cycle (DTN):</h3>
                    <p>On every DTN-th breath (currently set to <span id="modal-dtn-display" class="font-bold text-red-600">5</span>), you must perform a <span class="font-bold text-red-600">DOUBLE TAP</span> on the required side.</p>
                    <p class="text-sm italic mt-1">Example (DTN=5): B1 (Right, single), B2 (Left, single), B3 (Right, single), B4 (Left, single), B5 (<span class="font-bold text-red-600">Right, double tap sequence</span>). This means two separate taps on the Right side are required for this breath. The side does not flip until the double tap sequence is complete. Then, restart counting (B1) with the opposite side (Left).</p>
                    <p class="text-sm mt-2 font-semibold text-gray-800">Note: Double tap requires two quick, separate taps/key presses on the same side.</p>
                </div>

                <div class="bg-red-50 p-4 rounded-lg border border-red-200">
                    <h3 class="font-semibold text-lg text-red-700 mb-2">Focus Reset:</h3>
                    <p class="space-y-1">
                        Any <span class="font-bold">mistake</span> (wrong side) or failing to tap within the <span class="font-bold">Breath Window</span> will:
                        <ul class="list-disc list-inside ml-4">
                            <li>Reset your streak counter to 0.</li>
                            <li>Play a beep (Mistake Sound for incorrect tap, Focus Reminder for inactivity).</li>
                            <li>Visually highlight the required side.</li>
                        </ul>
                    </p>
                    <p class="text-sm mt-2">
                        Noticing your focus has shifted and gently bringing it back to your breath is an essential part of the meditation. Tap the correct side (or press the correct key) to silence the beep and resume your practice.
                    </p>
                </div>

            </div>

            <button id="close-instructions-btn" class="absolute top-4 right-4 p-2 text-gray-600 hover:text-gray-800 transition duration-150 rounded-full bg-gray-100 hover:bg-gray-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
    </div>

</body>
</html>