<!DOCTYPE html>
<html lang="en" class="dark"> <!-- Permanently set dark class on HTML -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"> <!-- Prevent zooming on mobile -->
    <title>Mindful Tap Meditation Game</title>
    <!-- FAVICON: Inlined SVG from icon.html for sharp, scalable icon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='45' fill='#E0F2FE'/><circle cx='50' cy='50' r='10' fill='#3B82F6'/><path d='M 50 10 L 50 40 M 50 60 L 50 90' stroke='#3B82F6' stroke-width='2' stroke-linecap='round' stroke-dasharray='5,5'/><g transform='translate(20 50) rotate(-45)'><rect x='-5' y='-5' width='20' height='20' rx='4' fill='#1D4ED8'/></g><g transform='translate(80 50) rotate(45)'><rect x='-15' y='-5' width='20' height='20' rx='4' fill='#1D4ED8'/></g><line x1='30' y1='50' x2='70' y2='50' stroke='#3B82F6' stroke-width='3' stroke-linecap='round'/><filter id='shadow'><feDropShadow dx='0' dy='0' stdDeviation='3' flood-color='#3B82F6' flood-opacity='0.5'/></filter><text x='50' y='55' font-family='Inter, sans-serif' font-size='12' fill='#FFFFFF' text-anchor='middle' font-weight='bold' filter='url(#shadow)'>TAP</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }

        /* Apply button styling to match the previous div structure, ensuring it fills the flex area */
        .side-tap-area {
            transition: background-color 0.2s, box-shadow 0.2s, color 0.2s;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            /* Make button fill its flex container */
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background-color: transparent; /* Reset default button background */
            padding: 1rem;
            -webkit-tap-highlight-color: transparent; /* Remove mobile tap highlight */
        }

        .side-tap-area.expected {
            /* Highlight when the expected side is active */
            box-shadow: 0 0 20px 5px rgba(59, 130, 246, 0.7); /* Blue glow */
            z-index: 10; /* Ensure glow is on top */
        }

        .side-tap-area:active {
            filter: brightness(0.9);
            transform: scale(0.98); /* Subtle press effect */
        }

        /* Dark mode defaults for tap areas (since dark mode is now permanent) */
        #left-area-btn { background-color: #374151; } /* gray-700 */
        #right-area-btn { background-color: #374151; } /* gray-700 */

        .beeping-bg {
            animation: pulse-bg 1s infinite alternate;
        }
        /* Keep pulse colors high contrast */
        /* Dark mode pulse animation remains */
        .beeping-bg {
            animation: dark-pulse-bg 1s infinite alternate;
        }
        @keyframes pulse-bg { /* Keeping the light mode pulse definition for robustness, although unused */
            0% { background-color: #fca5a5; }
            100% { background-color: #ef4444; }
        }
        @keyframes dark-pulse-bg {
             0% { background-color: #b91c1c; } /* Red-700 */
            100% { background-color: #dc2626; } /* Red-600 */
        }

        .stats-header {
            cursor: pointer;
            user-select: none;
            padding: 0.5rem;
            border-bottom: 2px solid #374151;
            transition: background-color 0.15s;
        }
        .stats-header:hover {
            background-color: #374151;
        }

        /* Heatmap Styles */
        .heatmap-grid {
            display: grid;
            grid-auto-flow: column;
            grid-template-rows: repeat(7, 1fr);
            gap: 3px;
        }
        .heat-cell {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            background-color: #1F2937; /* gray-800 - Level 0 */
            transition: background-color 0.3s;
        }
        /* Color Levels based on minutes */
        .level-1 { background-color: #4F46E5 !important; } /* Indigo-600 */
        .level-2 { background-color: #6366F1 !important; } /* Indigo-500 */
        .level-3 { background-color: #818CF8 !important; } /* Indigo-400 */
        .level-4 { background-color: #A5B4FC !important; } /* Indigo-300 */

    </style>

    <!-- 1. STATE & PERSISTENCE -->
    <script>
        // --- Game Constants and State ---
        const DTN_DEFAULT = 5;
        const DEFAULT_INACTIVITY_MS = 30000; // 30 seconds default
        const SESSION_DURATION_DEFAULT_MINUTES = 10;
        const LOCAL_STORAGE_KEY = 'mindfulTapSettings'; // Key for localStorage
        const HISTORY_STORAGE_KEY = 'mindfulTapHistory'; // NEW: Key for history

        const state = {
            dtn: DTN_DEFAULT,
            inactivityDurationMs: DEFAULT_INACTIVITY_MS,
            sessionDurationMinutes: SESSION_DURATION_DEFAULT_MINUTES,
            hideStatus: false,
            isVibrationEnabled: false,
            gameState: 'idle', // 'idle', 'running', 'paused', 'complete'
            breathCount: 0, // 1 to DTN
            currentStreak: 0,
            longestStreak: 0,
            expectedSide: 'right', // 'left' or 'right'
            expectedTapType: 'single', // 'single' or 'double' (denoting a DTN sequence)
            cycleStartSide: 'right', // The side the current cycle started on (B1)
            tapTimer: null, // Timer for the focus window (inactivity reset)
            isBeeping: false,
            isAwaitingSecondTap: false, // Tracks if the first tap of the DTN double sequence has occurred.

            // Stats tracking for current session
            currentSession: {
                startTime: 0,
                totalTaps: 0,
                mistakes: 0,
                inactivityResets: 0,
                longestStreak: 0,
            },

            // Timers for display and session management
            timeRemaining: DEFAULT_INACTIVITY_MS / 1000, // Breath window seconds remaining
            countdownInterval: null, // Interval for the breath window countdown
            sessionTimer: null, // Timeout for total session duration
            sessionTimeRemainingSeconds: 0,
            sessionCountdownInterval: null, // Interval for the session countdown
        };

        // --- Local Storage Persistence ---
        function loadSettings() {
            const storedSettings = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (storedSettings) {
                try {
                    const data = JSON.parse(storedSettings);
                    state.dtn = data.dtn || DTN_DEFAULT;
                    state.inactivityDurationMs = data.inactivityDurationMs || DEFAULT_INACTIVITY_MS;
                    state.sessionDurationMinutes = data.sessionDurationMinutes || SESSION_DURATION_DEFAULT_MINUTES;
                    state.longestStreak = data.longestStreak || 0;
                    state.hideStatus = data.hideStatus !== undefined ? data.hideStatus : false;
                    state.isVibrationEnabled = data.isVibrationEnabled !== undefined ? data.isVibrationEnabled : false;
                } catch (e) {
                    console.error("Error parsing settings from localStorage:", e);
                }
            }

            // Update input fields (relies on DOM being ready, handled in window.onload)
            if (document.readyState === 'complete') {
                document.getElementById('dtn-input').value = state.dtn;
                document.getElementById('duration-input').value = state.inactivityDurationMs / 1000;
                document.getElementById('session-duration-input').value = state.sessionDurationMinutes;
                document.getElementById('hide-status-input').checked = state.hideStatus;
                document.getElementById('vibration-input').checked = state.isVibrationEnabled;
            }
        }

        function saveSettings(dtn, inactivityDurationMs, sessionDurationMinutes, longestStreak, hideStatus, isVibrationEnabled) {
            state.longestStreak = longestStreak; // Update state before saving
            const settings = {
                dtn: dtn,
                inactivityDurationMs: inactivityDurationMs,
                sessionDurationMinutes: sessionDurationMinutes,
                longestStreak: longestStreak,
                hideStatus: hideStatus,
                isVibrationEnabled: isVibrationEnabled,
            };
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(settings));
        }

        function getSessionHistory() {
            const history = localStorage.getItem(HISTORY_STORAGE_KEY);
            return history ? JSON.parse(history) : [];
        }

        function saveSessionToHistory(sessionData) {
            const history = getSessionHistory();
            history.push(sessionData);
            localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));
        }
    </script>

    <!-- 2. AUDIO UTILITIES -->
    <script>
        // --- Audio Context for Focus Reminder (Beep) and Tones ---
        let audioContext;
        let oscillator;
        let gainNode;

        // Vibration Function
        function triggerVibration(pattern) {
            if (state.isVibrationEnabled && 'vibrate' in navigator) {
                navigator.vibrate(pattern);
            }
        }

        function startBeeping() {
            if (state.isBeeping) return;
            state.isBeeping = true;

            // VIBRATION INTEGRATION (Long pattern for inactivity)
            triggerVibration([500, 500, 500]);

            try {
                audioContext = audioContext || new (window.AudioContext || window.webkitAudioContext)();
                oscillator = audioContext.createOscillator();
                gainNode = audioContext.createGain();

                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4 note
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Start beeping pattern (simple on/off)
                const beepDuration = 0.2; // seconds
                const interval = 0.5; // seconds

                let time = audioContext.currentTime;

                // Create the repeating pattern
                for (let i = 0; i < 20; i++) { // Repeat 20 times, enough to get focus back
                    gainNode.gain.setValueAtTime(0.5, time + i * interval);
                    gainNode.gain.setValueAtTime(0, time + i * interval + beepDuration);
                }

                oscillator.start(time);
                oscillator.stop(time + 20 * interval);

                oscillator.onended = () => {
                    if (state.isBeeping) {
                        // Restart beeping if still required
                        startBeeping();
                    }
                };

            } catch (e) {
                console.warn("Audio API not supported or failed to start:", e);
            }
        }

        function stopBeeping() {
            if (!state.isBeeping) return;
            state.isBeeping = false;
            // Stop vibration immediately
            triggerVibration(0);

            if (oscillator) {
                try {
                    // Smoothly fade out the gain to avoid click sound
                    gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.1);
                    oscillator.stop(audioContext.currentTime + 0.1);
                } catch (e) {
                    console.error("Error stopping audio:", e);
                }
            }
        }

        function playMistakeTone() {
            // VIBRATION INTEGRATION (Short pulse for mistake)
            triggerVibration(200);

            try {
                audioContext = audioContext || new (window.AudioContext || window.webkitAudioContext)();
                const tone = audioContext.createOscillator();
                const gain = audioContext.createGain();

                tone.type = 'sawtooth';
                tone.frequency.setValueAtTime(120, audioContext.currentTime); // Low frequency tone
                gain.gain.setValueAtTime(0.3, audioContext.currentTime); // Volume

                tone.connect(gain);
                gain.connect(audioContext.destination);

                tone.start(audioContext.currentTime);
                tone.stop(audioContext.currentTime + 0.15); // Short duration (150ms)

            } catch (e) {
                console.warn("Audio API not supported or failed to play mistake tone:", e);
            }
        }

        /**
         * Plays a single resonant gong tone.
         */
        function playSingleGong() {
            try {
                audioContext = audioContext || new (window.AudioContext || window.webkitAudioContext)();

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.type = 'sine';

                // Low frequency start for the bell/gong sound
                oscillator.frequency.setValueAtTime(110, audioContext.currentTime);

                // Volume envelope for a gentle strike and fade out
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.8, audioContext.currentTime + 0.05); // Quick rise to strike
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 3); // Slow, gentle fade over 3s

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 3); // Stop after 3 seconds

            } catch (e) {
                console.warn("Audio API not supported or failed to play gong tone:", e);
            }
        }

        /**
         * Plays the gong sound three times with a delay and vibrates three times.
         */
        function playGongSequence() {
            const numGongs = 3;
            const delayMs = 2500; // Delay between gongs (2.5 seconds)
            const vibrationDuration = 500; // Duration of each vibration pulse

            for (let i = 0; i < numGongs; i++) {
                setTimeout(() => {
                    playSingleGong();
                    // Vibrate concurrently with the gong
                    triggerVibration(vibrationDuration);
                }, i * delayMs);
            }
        }
    </script>

    <!-- 3. GAME CORE LOGIC & UI UPDATES -->
    <script>
        // --- Utility Functions ---
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const paddedSeconds = String(seconds).padStart(2, '0');
            return `${minutes}:${paddedSeconds}`;
        }

        function formatSessionDuration(totalSeconds) {
            if (totalSeconds < 60) return `${totalSeconds}s`;
            const minutes = Math.floor(totalSeconds / 60);
            const remainingSeconds = totalSeconds % 60;
            if (remainingSeconds === 0) return `${minutes}m`;
            return `${minutes}m ${remainingSeconds}s`;
        }


        // --- Game Logic Functions ---
        function updateUI(statusOverride = null) {
            const leftArea = document.getElementById('left-area-btn');
            const rightArea = document.getElementById('right-area-btn');
            const statusDisplay = document.getElementById('status-display');
            const streakDisplay = document.getElementById('streak-display');
            const longestStreakDisplay = document.getElementById('longest-streak-display');
            const startBtn = document.getElementById('start-btn');
            const stopBtn = document.getElementById('stop-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const modalDtnDisplay = document.getElementById('modal-dtn-display');
            const timeRemainingDisplay = document.getElementById('time-remaining-display');
            const sessionTimeDisplay = document.getElementById('session-time-display');

            // 1. Game State and Buttons
            let currentStatus = `Status: ${state.gameState.toUpperCase()}`;
            if (statusOverride === 'complete') {
                currentStatus = '<span class="text-green-500 font-bold">Session Complete!</span>';
            }

            const isGameActive = state.gameState === 'running' || state.gameState === 'paused';
            const isRunning = state.gameState === 'running';
            const isPaused = state.gameState === 'paused';
            const isIdle = state.gameState === 'idle' || state.gameState === 'complete';


            // Apply visibility setting: Hide only when active AND setting is enabled
            if (state.hideStatus && isRunning) {
                statusDisplay.classList.add('hidden');
            } else {
                statusDisplay.classList.remove('hidden');
                statusDisplay.innerHTML = currentStatus; // Set the generic status if not hidden
            }

            // Button visibility and text logic
            stopBtn.disabled = isIdle; // Stop is available in Running or Paused

            if (isIdle) {
                startBtn.textContent = 'Start';
                startBtn.classList.remove('hidden');
                pauseBtn.classList.add('hidden');
            } else if (isRunning) {
                startBtn.classList.add('hidden'); // Hide Start button
                pauseBtn.textContent = 'Pause';
                pauseBtn.classList.remove('hidden'); // Show Pause button
            } else if (isPaused) {
                startBtn.textContent = 'Resume';
                startBtn.classList.remove('hidden'); // Show Resume button
                pauseBtn.classList.add('hidden'); // Hide Pause button
            }

            startBtn.disabled = isRunning; // Start button is disabled only if running (prevents double clicking)

            // 2. Tap Area Highlight
            leftArea.classList.remove('expected');
            rightArea.classList.remove('expected');

            if (isRunning) {
                let tapText = (state.isAwaitingSecondTap ? 'Second Tap' : state.expectedTapType === 'double' ? 'First Tap (DTN)' : 'Single Tap');

                // Highlight single expected side
                const expectedArea = document.getElementById(`${state.expectedSide}-area-btn`);
                expectedArea.classList.add('expected');

                if (!state.hideStatus) {
                    let breathStatus = `Breath ${state.breathCount}/${state.dtn}`;
                    if (state.expectedTapType === 'double' && state.isAwaitingSecondTap) {
                        // Display the full breath count for the full sequence
                        breathStatus = `Breath ${state.dtn}/${state.dtn}`;
                    }

                    // Removed dark mode text classes as body/parent elements handle them
                    statusDisplay.innerHTML = `${breathStatus} | <span class="text-blue-500">${state.expectedSide.toUpperCase()} (${tapText})</span>`;
                }
            }

            // 3. Beeping/Focus Reset Visual
            const gameArea = document.getElementById('game-area');
            gameArea.classList.toggle('beeping-bg', state.isBeeping);

            // 4. Streaks
            streakDisplay.textContent = `Streak: ${state.currentStreak}`;
            longestStreakDisplay.textContent = `Longest: ${state.longestStreak}`;

            // 5. Timer Displays
            if (isGameActive) {
                timeRemainingDisplay.textContent = `Breath Window: ${Math.max(0, state.timeRemaining)}s`;
                sessionTimeDisplay.textContent = `Session Time: ${formatTime(state.sessionTimeRemainingSeconds)}`;
            } else {
                timeRemainingDisplay.textContent = 'Breath Window: --s';
                sessionTimeDisplay.textContent = 'Session Time: --:--';
            }

            // 6. Modal Input Updates
            if (modalDtnDisplay) {
                modalDtnDisplay.textContent = state.dtn;
            }
        }

        /**
         * Finalizes the session, logs data, and resets state.
         * @param {('manual'|'complete')} trigger
         */
        function stopMeditation(trigger = 'manual') {
            stopBeeping();

            // Store duration before clearing timers
            const sessionEndTimestamp = Date.now();
            const sessionTotalTimeSeconds = state.sessionDurationMinutes * 60 - state.sessionTimeRemainingSeconds;

            // Clear all timers
            clearTimeout(state.tapTimer);
            clearInterval(state.countdownInterval);
            clearTimeout(state.sessionTimer);
            clearInterval(state.sessionCountdownInterval);

            state.tapTimer = null;
            state.countdownInterval = null;
            state.sessionTimer = null;
            state.sessionCountdownInterval = null;

            const finalStreak = state.currentStreak;

            // Log session history
            const hitRate = (state.currentSession.totalTaps > 0)
                ? (state.currentSession.totalTaps / (state.currentSession.totalTaps + state.currentSession.mistakes + state.currentSession.inactivityResets))
                : 0;

            const sessionData = {
                date: new Date(sessionEndTimestamp).toLocaleString(),
                duration: formatSessionDuration(sessionTotalTimeSeconds),
                durationSeconds: sessionTotalTimeSeconds,
                dtn: state.dtn,
                totalTaps: state.currentSession.totalTaps,
                mistakes: state.currentSession.mistakes,
                inactivityResets: state.currentSession.inactivityResets,
                finalStreak: finalStreak,
                hitRate: (hitRate * 100).toFixed(1) + '%',
            };

            if (sessionTotalTimeSeconds > 5) { // Only log meaningful sessions
                saveSessionToHistory(sessionData);
            }

            // Play gong sequence if session completed automatically
            if (trigger === 'complete') {
                playGongSequence(); // Calls the function that plays 3 gongs and vibrates 3 times
            }

            // Save streak if it's a record
            if (finalStreak > state.longestStreak) {
                saveSettings(state.dtn, state.inactivityDurationMs, state.sessionDurationMinutes, finalStreak, state.hideStatus, state.isVibrationEnabled);
            }

            // Reset streak and breath tracking
            state.currentStreak = 0;
            state.breathCount = 0; // Ensures restart goes to B1
            state.expectedSide = 'right';
            state.expectedTapType = 'single'; // Reset tap type
            state.cycleStartSide = 'right';
            state.isAwaitingSecondTap = false; // Reset DTN sequence flag

            // Reset current session tracking
            state.currentSession = { startTime: 0, totalTaps: 0, mistakes: 0, inactivityResets: 0, longestStreak: 0 };

            // Set final game state and update UI
            state.gameState = 'idle';
            updateUI(trigger === 'complete' ? 'complete' : null);
        }

        // NEW: Pause Meditation Function
        function pauseMeditation() {
            if (state.gameState !== 'running') return;

            // 1. Stop all intervals/timeouts
            clearTimeout(state.tapTimer);
            clearInterval(state.countdownInterval);
            clearInterval(state.sessionCountdownInterval);

            // 2. Clear the main session timer
            clearTimeout(state.sessionTimer);

            state.tapTimer = null;
            state.countdownInterval = null;
            state.sessionTimer = null;

            // 3. Update game state and UI
            state.gameState = 'paused';
            updateUI();
        }

        // NEW: Resume Meditation Function
        function resumeMeditation() {
            if (state.gameState !== 'paused') return;

            state.gameState = 'running';

            // 1. Restart breath window timer from scratch
            startTapTimer();

            // 2. Restart the session timer from the time we paused at
            startSessionTimer(state.sessionTimeRemainingSeconds);

            updateUI();
        }


        /**
         * Resets the breath counter/streak due to mistake or inactivity, but keeps session running.
         * 'mistake': input error, plays tone.
         * 'inactivity': timeout, starts beeping.
         * 'start': manual start, no sound.
         */
        function resetFocus(trigger) {
            console.log(`Resetting focus due to: ${trigger}`);

            // Track mistakes for statistics
            if (trigger === 'mistake') {
                playMistakeTone();
                state.currentSession.mistakes++;
            } else if (trigger === 'inactivity') {
                state.currentSession.inactivityResets++;
            }

            // Save current streak if it's the longest
            if (state.currentStreak > state.longestStreak) {
                saveSettings(state.dtn, state.inactivityDurationMs, state.sessionDurationMinutes, state.currentStreak, state.hideStatus, state.isVibrationEnabled);
            }
            // Also update current session longest streak
            if (state.currentStreak > state.currentSession.longestStreak) {
                state.currentSession.longestStreak = state.currentStreak;
            }

            // Reset breath/streak counters
            state.currentStreak = 0;
            state.breathCount = 1; // Starts on breath 1
            state.cycleStartSide = 'right';
            state.expectedSide = 'right';
            state.expectedTapType = 'single'; // B1 is always a single tap
            state.isAwaitingSecondTap = false; // Reset DTN sequence flag

            if (trigger === 'inactivity') {
                state.gameState = 'paused';
                startBeeping();
            } else { // Handles 'mistake' and 'start'
                state.gameState = 'running';
                startTapTimer();
            }

            // Start time tracking for new session
            if (trigger === 'start') {
                state.currentSession.startTime = Date.now();
                state.currentSession.longestStreak = 0;
                state.currentSession.mistakes = 0;
                state.currentSession.totalTaps = 0;
                state.currentSession.inactivityResets = 0;
            }


            updateUI();
        }

        // Starts or restarts the breath focus timer (inactivity reset)
        function startTapTimer() {
            clearTimeout(state.tapTimer);
            clearInterval(state.countdownInterval);

            // 1. Start the inactivity timer using the user-defined duration
            state.tapTimer = setTimeout(() => {
                resetFocus('inactivity');
            }, state.inactivityDurationMs);

            // 2. Start the countdown display
            const durationInSeconds = state.inactivityDurationMs / 1000;
            state.timeRemaining = durationInSeconds;

            state.countdownInterval = setInterval(() => {
                state.timeRemaining = Math.max(0, state.timeRemaining - 1);
                updateUI();

                if (state.timeRemaining <= 0) {
                    clearInterval(state.countdownInterval);
                    state.countdownInterval = null;
                }
            }, 1000);

            updateUI();
        }

        // Starts the main session duration timer (accepts optional initialSeconds for resume)
        function startSessionTimer(initialSeconds = null) {
            clearTimeout(state.sessionTimer);
            clearInterval(state.sessionCountdownInterval);

            // Determine the starting time for the timer
            const secondsToRun = initialSeconds !== null ? initialSeconds : state.sessionDurationMinutes * 60;
            const durationMs = secondsToRun * 1000;

            // Set up the main timer that stops the session
            state.sessionTimer = setTimeout(() => {
                stopMeditation('complete');
            }, durationMs);

            // Set up the display countdown
            state.sessionTimeRemainingSeconds = secondsToRun;
            state.sessionCountdownInterval = setInterval(() => {
                state.sessionTimeRemainingSeconds = Math.max(0, state.sessionTimeRemainingSeconds - 1);
                updateUI();
                if (state.sessionTimeRemainingSeconds <= 0) {
                    clearInterval(state.sessionCountdownInterval);
                    state.sessionCountdownInterval = null;
                }
            }, 1000);
        }

        /**
         * Advances the breath count, streak, and expected side/tap type.
         * Only called when a *breath* (either single tap or successful double-tap sequence) is complete.
         */
        function advanceBreath() {
            state.currentSession.totalTaps++; // Track successful tap
            state.currentStreak++;

            if (state.expectedTapType === 'double') {
                // DTN double tap sequence just completed (after the second tap).
                // Complete the cycle and flip the side.
                state.breathCount = 1;
                state.cycleStartSide = (state.cycleStartSide === 'right' ? 'left' : 'right');
                state.expectedSide = state.cycleStartSide;
                state.expectedTapType = 'single';
            } else {
                // Regular single tap just completed.
                state.breathCount++;
                state.expectedSide = (state.expectedSide === 'right' ? 'left' : 'right');

                if (state.breathCount === state.dtn) {
                    state.expectedTapType = 'double';
                } else {
                    state.expectedTapType = 'single';
                }
            }

            // Successfully processed, restart breath window timer
            startTapTimer();
        }

        // NEW: Function to aggregate historical data into daily minutes
        function getDailyActivity() {
            const history = getSessionHistory();
            const dailyActivity = {}; // Key: YYYY-MM-DD, Value: total duration in minutes

            history.forEach(session => {
                // Date format is already localized string, needs parsing
                // Assuming session.date is a string like "12/8/2025, 6:47:21 PM"
                const date = new Date(session.date);
                // Format date as YYYY-MM-DD
                const dateKey = date.toISOString().split('T')[0];
                const durationMinutes = Math.ceil(session.durationSeconds / 60);

                if (dailyActivity[dateKey]) {
                    dailyActivity[dateKey] += durationMinutes;
                } else {
                    dailyActivity[dateKey] = durationMinutes;
                }
            });
            return dailyActivity;
        }

        // NEW: Function to render the GitHub-like heatmap
        function renderHeatmap() {
            const container = document.getElementById('heatmap-container');
            if (!container) return;

            container.innerHTML = '';
            const dailyActivity = getDailyActivity();

            const today = new Date();
            // FIX 1: Corrected variable name
            const oneYearAgo = new Date(today.getFullYear() - 1, today.getMonth(), today.getDate() + 1);

            const daysOfWeek = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            // Add day labels (Sun, Mon, etc.)
            const dayLabels = document.createElement('div');
            dayLabels.className = 'grid grid-rows-7 gap-3 mr-1 text-xs text-gray-400';
            daysOfWeek.forEach((day, index) => {
                if (index === 0 || index === 2 || index === 4 || index === 6) { // Only show Sun, Tue, Thu, Sat
                     const label = document.createElement('div');
                     label.textContent = day;
                     label.className = 'h-3 text-center leading-3';
                     dayLabels.appendChild(label);
                } else {
                     const empty = document.createElement('div');
                     empty.className = 'h-3';
                     dayLabels.appendChild(empty);
                }
            });
            container.appendChild(dayLabels);

            // Create the main grid container
            const grid = document.createElement('div');
            grid.className = 'heatmap-grid flex-1';

            // FIX 1: Use corrected variable name
            let currentDate = new Date(oneYearAgo);
            currentDate.setHours(0, 0, 0, 0); // Normalize to start of day

            const cells = [];
            const dayCount = 365;

            // Generate cells for the entire year
            for (let i = 0; i < dayCount; i++) {
                const dateKey = currentDate.toISOString().split('T')[0];
                const minutes = dailyActivity[dateKey] || 0;

                const cell = document.createElement('div');
                cell.className = 'heat-cell';
                cell.setAttribute('title', `${minutes} min on ${dateKey}`);

                // Determine activity level based on minutes
                let level = 0;
                if (minutes >= 31) {
                    level = 1; // Indigo-600 (Darkest)
                } else if (minutes >= 16) {
                    level = 2; // Indigo-500
                } else if (minutes >= 1) {
                    level = 3; // Indigo-400
                }

                if (level > 0) {
                    // Note: Levels are reversed for visual effect: 1=highest activity, 4=lowest visible activity
                    cell.classList.add(`level-${4 - level}`);
                }

                cells.push(cell);
                currentDate.setDate(currentDate.getDate() + 1);
            }

            // Determine the starting day of the grid (Sunday = 0)
            // FIX 1: Use corrected variable name
            const firstDayOfWeek = new Date(oneYearAgo).getDay();

            // Create dummy cells for alignment (to start grid properly on Sunday)
            for (let i = 0; i < firstDayOfWeek; i++) {
                 const dummy = document.createElement('div');
                 dummy.className = 'heat-cell invisible';
                 grid.appendChild(dummy);
            }

            // Append all generated cells
            cells.forEach(cell => grid.appendChild(cell));
            container.appendChild(grid);
        }

        // NEW: Stats Rendering Function
        function renderStats() {
            const history = getSessionHistory();
            const tableBody = document.getElementById('stats-table-body');

            // Clear existing rows
            tableBody.innerHTML = '';

            if (history.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="5" class="p-4 text-center text-gray-400">No meditation sessions logged yet.</td></tr>';
                return;
            }

            // Reverse history to show latest sessions first
            const reversedHistory = history.slice().reverse();

            reversedHistory.forEach((session, index) => {
                const row = tableBody.insertRow();
                row.className = index % 2 === 0 ? 'bg-gray-800' : 'bg-gray-700';

                // Date
                row.insertCell().textContent = session.date;

                // Duration
                row.insertCell().textContent = session.duration;

                // DTN
                row.insertCell().textContent = session.dtn;

                // Hit Rate
                const hitRateCell = row.insertCell();
                hitRateCell.textContent = session.hitRate;

                // Color code hit rate
                const rate = parseFloat(session.hitRate);
                if (rate >= 90) {
                    hitRateCell.classList.add('text-green-400', 'font-bold');
                } else if (rate >= 70) {
                    hitRateCell.classList.add('text-yellow-400');
                } else {
                    hitRateCell.classList.add('text-red-400');
                }

                // Longest Streak
                row.insertCell().textContent = session.finalStreak;
            });
        }
    </script>

    <!-- 4. INPUT AND EVENT HANDLERS -->
    <script>
        /**
         * Main input handling function. All inputs (screen click/key press) are considered single taps.
         */
        function handleTap(actualSide) {
            // Prevent interaction if modals are open or game is idle/complete/paused
            if (document.getElementById('instructions-modal').classList.contains('hidden') === false ||
                document.getElementById('settings-modal').classList.contains('hidden') === false ||
                document.getElementById('stats-modal').classList.contains('hidden') === false ||
                state.gameState === 'paused' || state.gameState === 'idle' || state.gameState === 'complete') {
                return;
            }
            if (state.gameState !== 'running' && state.gameState !== 'paused') return;

            // If in "paused" (beeping) state, only accept correct side to resume
            if (state.isBeeping) {
                if (actualSide === state.expectedSide) {
                    stopBeeping();
                    state.gameState = 'running';
                    startTapTimer();
                }
                return;
            }

            const correctSide = (actualSide === state.expectedSide);

            if (correctSide) {
                if (state.expectedTapType === 'double') {
                    if (state.isAwaitingSecondTap) {
                        // SUCCESSFUL SECOND TAP (completes the DTN sequence)
                        state.isAwaitingSecondTap = false;
                        advanceBreath();
                    } else {
                        // SUCCESSFUL FIRST TAP (starts the DTN sequence)
                        state.isAwaitingSecondTap = true;
                        // Restart timer for the second tap. Streak is advanced only on completion.
                        startTapTimer();
                    }
                } else {
                    // Success on regular single tap.
                    advanceBreath();
                }
            } else {
                // MISTAKE (wrong side)
                resetFocus('mistake');
                state.isAwaitingSecondTap = false; // Reset sequence if failed
            }
        }

        // 1. Screen Tap Logic (Simplest form: one click = one tap)
        function handleScreenTap(event) {
            const actualSide = event.currentTarget.dataset.side;
            handleTap(actualSide);
        }

        // 2. Keyboard Logic (Simplest form: one keydown = one tap)
        function handleKeyDown(event) {
            const key = event.key.toLowerCase();
            let actualSide = null;

            if (key === 'f') { actualSide = 'left'; }
            else if (key === 'j') { actualSide = 'right'; }
            else { return; }

            if (event.repeat) return; // Prevent continuous tapping on key hold
            if (state.gameState !== 'running' && state.gameState !== 'paused') return;

            handleTap(actualSide);
        }

        // 3. Modal Handlers
        function openInstructions() {
            document.getElementById('instructions-modal').classList.remove('hidden');
        }

        function closeInstructions() {
            document.getElementById('instructions-modal').classList.add('hidden');
        }

        function openSettings() {
             // Ensure the inputs reflect the current state before opening
            document.getElementById('dtn-input').value = state.dtn;
            document.getElementById('duration-input').value = state.inactivityDurationMs / 1000;
            document.getElementById('session-duration-input').value = state.sessionDurationMinutes;
            document.getElementById('hide-status-input').checked = state.hideStatus;
            document.getElementById('vibration-input').checked = state.isVibrationEnabled;

            document.getElementById('settings-modal').classList.remove('hidden');
        }

        function closeSettings() {
            document.getElementById('settings-modal').classList.add('hidden');
            // Re-run UI update to ensure values are correctly reflected
            updateUI();
        }

        function closeStats() { // NEW
            document.getElementById('stats-modal').classList.add('hidden');
        }

        function openStats() {
            renderStats();
            renderHeatmap(); // Render the heatmap when opening stats
            document.getElementById('stats-modal').classList.remove('hidden');
        }

        // --- Initialization ---

        window.onload = function() {
            loadSettings(); // Load settings from localStorage

            // Add event listeners for tap areas (now buttons)
            document.getElementById('left-area-btn').addEventListener('click', handleScreenTap);
            document.getElementById('right-area-btn').addEventListener('click', handleScreenTap);

            // Add event listeners for keyboard input
            document.addEventListener('keydown', handleKeyDown);

            // Add event listeners for modal buttons
            document.getElementById('instructions-btn').addEventListener('click', openInstructions);
            document.getElementById('close-instructions-btn').addEventListener('click', closeInstructions);
            document.getElementById('settings-btn').addEventListener('click', openSettings);
            document.getElementById('close-settings-btn').addEventListener('click', closeSettings);
            document.getElementById('stats-btn').addEventListener('click', openStats); // NEW
            document.getElementById('close-stats-btn').addEventListener('click', closeStats); // NEW

            // Add event listeners for control buttons
            document.getElementById('start-btn').addEventListener('click', () => {
                if (state.gameState === 'idle' || state.gameState === 'complete') {
                    // Start a fresh meditation session
                    startSessionTimer(); // Start the overall session timer (start fresh)
                    resetFocus('start'); // Start the breath tracking
                } else if (state.gameState === 'paused') {
                    // Resume a paused session
                    resumeMeditation();
                }
            });

            document.getElementById('stop-btn').addEventListener('click', () => stopMeditation('manual'));
            document.getElementById('pause-btn').addEventListener('click', pauseMeditation);

            document.getElementById('save-settings-btn').addEventListener('click', () => {
                const dtnInput = document.getElementById('dtn-input');
                const durationInput = document.getElementById('duration-input');
                const sessionDurationInput = document.getElementById('session-duration-input');
                const hideStatusInput = document.getElementById('hide-status-input');
                const vibrationInput = document.getElementById('vibration-input');

                const newDTN = parseInt(dtnInput.value, 10);
                const newDurationSec = parseInt(durationInput.value, 10);
                const newDurationMs = newDurationSec * 1000;
                const newSessionDurationMin = parseInt(sessionDurationInput.value, 10);
                const newHideStatus = hideStatusInput.checked;
                const newVibrationEnabled = vibrationInput.checked;

                let isValid = true;
                let feedback = '';

                if (newDTN < 2) {
                    feedback += "DTN must be 2 or greater. ";
                    dtnInput.value = state.dtn;
                    isValid = false;
                }
                if (newDurationSec < 5 || newDurationSec > 180) {
                     feedback += "Breath Window Duration must be between 5 and 180 seconds. ";
                     durationInput.value = state.inactivityDurationMs / 1000;
                     isValid = false;
                }
                if (newSessionDurationMin < 1 || newSessionDurationMin > 180) {
                     feedback += "Session Duration must be between 1 and 180 minutes. ";
                     sessionDurationInput.value = state.sessionDurationMinutes;
                     isValid = false;
                }

                if (isValid) {
                    state.dtn = newDTN;
                    state.inactivityDurationMs = newDurationMs;
                    state.sessionDurationMinutes = newSessionDurationMin;
                    state.hideStatus = newHideStatus;
                    state.isVibrationEnabled = newVibrationEnabled;

                    saveSettings(state.dtn, state.inactivityDurationMs, state.sessionDurationMinutes, state.longestStreak, state.hideStatus, state.isVibrationEnabled);

                    // Show confirmation message
                    const originalText = document.getElementById('save-settings-btn').textContent;
                    document.getElementById('save-settings-btn').textContent = 'Saved!';
                    setTimeout(() => {
                        document.getElementById('save-settings-btn').textContent = originalText;
                        closeSettings(); // Close modal after saving
                    }, 1000);

                    // If game is running, restart breath timer with new duration, but session timer continues unless reset.
                    if (state.gameState === 'running' || state.gameState === 'paused') {
                        startTapTimer();
                    }
                    updateUI();

                } else {
                    console.error("Settings validation failed:", feedback);
                }
            });


            // Initial UI setup
            updateUI();
        };
    </script>
</head>
<body class="bg-gray-900 min-h-screen flex flex-col items-center p-4 transition-colors duration-300 h-screen overflow-hidden"> <!-- Permanently set dark background + full screen -->

    <!-- Header -->
    <header class="w-full max-w-4xl text-center mb-2 md:mb-8 flex-none">
        <h1 class="text-3xl font-bold text-gray-100 mb-2">Mindful Tap: Breath Focus Game</h1>
        <p class="text-sm text-gray-400 mb-4">
            A tool to anchor your mind to your breath. Observe your breath, then tap the required side.
        </p>
    </header>

    <!-- Game Status and Controls -->
    <div class="w-full max-w-4xl bg-gray-800 p-6 rounded-lg shadow-xl mb-4 flex-none flex flex-col md:flex-row justify-between items-center space-y-4 md:space-y-0 transition-colors duration-300">
        <div id="status-display" class="text-lg font-semibold text-gray-300">Status: Idle</div>

        <!-- Central display for Streak and Timer -->
        <div class="text-center space-y-1">
            <div id="session-time-display" class="text-xl font-bold text-gray-100">Session Time: --:--</div>
            <div id="time-remaining-display" class="text-sm text-gray-400">Breath Window: --s</div>
            <div id="streak-display" class="text-2xl font-extrabold text-indigo-600">Streak: 0</div>
            <div id="longest-streak-display" class="text-sm text-gray-400">Longest: 0</div>
        </div>

        <div class="flex flex-wrap justify-center gap-2 md:gap-4 w-full md:w-auto">
            <button id="stats-btn" class="px-4 py-3 bg-purple-500 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-purple-600 transition duration-200 transform hover:scale-105">
                Stats
            </button>
            <button id="settings-btn" class="px-4 py-3 bg-blue-500 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-blue-600 transition duration-200 transform hover:scale-105">
                Settings
            </button>
            <button id="instructions-btn" class="px-4 py-3 bg-gray-500 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-gray-600 transition duration-200 transform hover:scale-105">
                ? Instructions
            </button>

            <!-- Pause Button -->
            <button id="pause-btn" class="px-8 py-3 bg-yellow-600 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-yellow-700 transition duration-200 transform hover:scale-105 hidden">
                Pause
            </button>

            <!-- Stop Button -->
            <button id="stop-btn" class="px-8 py-3 bg-red-600 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-red-700 transition duration-200 transform hover:scale-105" disabled>
                Stop
            </button>

            <!-- Start/Resume Button -->
            <button id="start-btn" class="px-8 py-3 bg-green-600 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-green-700 transition duration-200 transform hover:scale-105">
                Start
            </button>
        </div>
    </div>

    <!-- Audio Player (Hidden) -->
    <audio id="audio-player" class="hidden"></audio>

    <!-- Main Tap Area -->
    <main id="game-area" class="flex-1 w-full max-w-4xl flex flex-col md:flex-row rounded-xl overflow-hidden shadow-2xl transition duration-500 min-h-0">

        <!-- Left Tap Area Button -->
        <button id="left-area-btn" class="side-tap-area flex-1 border-b md:border-r md:border-b-0 border-gray-700" data-side="left">
            <div class="text-center">
                <p class="text-3xl font-bold text-gray-100">Left Tap</p>
                <p class="text-xl text-gray-300 mt-1">(Key: F)</p>
            </div>
        </button>

        <!-- Right Tap Area Button -->
        <button id="right-area-btn" class="side-tap-area flex-1" data-side="right">
            <div class="text-center">
                <p class="text-3xl font-bold text-gray-100">Right Tap</p>
                <p class="text-xl text-gray-300 mt-1">(Key: J)</p>
            </div>
        </button>

    </main>

    <!-- Settings Modal Screen -->
    <div id="settings-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-gray-900 bg-opacity-80 p-4 transition-opacity duration-300">
        <div class="bg-gray-800 text-gray-100 w-11/12 max-w-md p-8 rounded-xl shadow-2xl relative max-h-[90vh] overflow-y-auto transition-colors duration-300">
            <h2 class="text-2xl font-bold mb-6 border-b pb-2 border-gray-700">Game Settings</h2>

            <div class="space-y-6">

                <!-- Session Duration Setting -->
                <div class="flex flex-col space-y-2 bg-gray-700 p-4 rounded-lg">
                    <label for="session-duration-input" class="font-medium text-lg">Session Duration:</label>
                    <div class="flex items-center space-x-2">
                         <input id="session-duration-input" type="number" value="10" min="1" max="180" class="w-full p-2 border border-gray-600 rounded-md text-center text-lg focus:ring-blue-500 focus:border-blue-500 bg-gray-900 text-white">
                         <span class="text-gray-300 font-medium">minutes</span>
                    </div>
                    <p class="text-sm text-gray-400">The total time the meditation will run (1-180 min).</p>
                </div>

                <!-- Focus Window Duration Setting -->
                <div class="flex flex-col space-y-2 bg-gray-700 p-4 rounded-lg">
                    <label for="duration-input" class="font-medium text-lg">Focus Window Duration:</label>
                    <div class="flex items-center space-x-2">
                         <input id="duration-input" type="number" value="30" min="5" max="180" class="w-full p-2 border border-gray-600 rounded-md text-center text-lg focus:ring-blue-500 focus:border-blue-500 bg-gray-900 text-white">
                         <span class="text-gray-300 font-medium">seconds</span>
                    </div>
                    <p class="text-sm text-gray-400">Time (in seconds) allowed between taps before focus reset.</p>
                </div>

                <!-- DTN Setting (Now Cycle Length) -->
                <div class="flex flex-col space-y-2 bg-gray-700 p-4 rounded-lg">
                    <label for="dtn-input" class="font-medium text-lg">Double Tap Number (DTN):</label>
                    <input id="dtn-input" type="number" value="5" min="2" class="w-full p-2 border border-gray-600 rounded-md text-center text-lg focus:ring-blue-500 focus:border-blue-500 bg-gray-900 text-white">
                    <p class="text-sm text-gray-400">The cycle length. The DTN-th breath will require a double tap on the required side, after which the alternating pattern flips.</p>
                </div>

                <!-- Hide Status Setting -->
                <div class="flex flex-col space-y-2 bg-gray-700 p-4 rounded-lg">
                    <label for="hide-status-input" class="font-medium text-lg flex items-center justify-between">
                        Hide Status Display
                        <input id="hide-status-input" type="checkbox" class="h-6 w-6 text-blue-600 border-gray-600 rounded focus:ring-blue-500">
                    </label>
                    <p class="text-sm text-gray-400">Hide the detailed "Status" line during meditation for a cleaner view.</p>
                </div>

                <!-- Vibration Setting -->
                <div class="flex flex-col space-y-2 bg-gray-700 p-4 rounded-lg">
                    <label for="vibration-input" class="font-medium text-lg flex items-center justify-between">
                        Enable Vibration Feedback
                        <input id="vibration-input" type="checkbox" class="h-6 w-6 text-blue-600 border-gray-600 rounded focus:ring-blue-500">
                    </label>
                    <p class="text-sm text-gray-400">Triggers device vibration for focus resets and mistakes (requires compatible device).</p>
                </div>

            </div>

            <button id="save-settings-btn" class="mt-6 w-full px-4 py-3 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
                Save All Settings
            </button>


            <button id="close-settings-btn" class="absolute top-4 right-4 p-2 text-gray-400 hover:text-gray-200 transition duration-150 rounded-full bg-gray-700 hover:bg-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
    </div>

    <!-- Instructions Modal Screen -->
    <div id="instructions-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-gray-900 bg-opacity-80 p-4 transition-opacity duration-300">
        <div class="bg-gray-800 text-gray-100 w-11/12 max-w-3xl p-8 rounded-xl shadow-2xl relative max-h-[90vh] overflow-y-auto transition-colors duration-300">
            <h2 class="text-3xl font-bold text-gray-100 mb-6 border-b pb-2 border-gray-700">Mindful Tap Instructions</h2>

            <div class="text-base space-y-4">
                <p>Before starting, take a comfortable position. You may close your eyes if you wish.</p>

                <div class="bg-blue-900 p-4 rounded-lg border border-blue-700">
                    <h3 class="font-semibold text-lg text-blue-400 mb-2">The Basic Rhythm:</h3>
                    <p class="mb-2">Observe your complete breath cycle (in-breath and out-breath).</p>
                    <ul class="list-disc list-inside space-y-1 ml-4">
                        <li>After each completed breath, tap the screen or press a key.</li>
                        <li>The required tap side alternates: <span class="font-bold text-gray-100">Right (J key)</span> then <span class="font-bold text-gray-100">Left (F key)</span>.</li>
                        <li>The meditation starts with a tap on the <span class="font-bold text-blue-400">Right side</span>.</li>
                    </ul>
                </div>

                <div class="bg-yellow-900 p-4 rounded-lg border border-yellow-700">
                    <h3 class="font-semibold text-lg text-yellow-400 mb-2">Double Tap Cycle (DTN):</h3>
                    <p>On every DTN-th breath (currently set to <span id="modal-dtn-display" class="font-bold text-red-400">5</span>), you must perform a <span class="font-bold text-red-400">DOUBLE TAP</span> on the required side.</p>
                    <p class="text-sm italic mt-1">Example (DTN=5): B1 (Right, single), B2 (Left, single), B3 (Right, single), B4 (Left, single), B5 (<span class="font-bold text-red-400">Right, double tap sequence</span>). This means two separate taps on the Right side are required for this breath. The side does not flip until the double tap sequence is complete. Then, restart counting (B1) with the opposite side (Left).</p>
                    <p class="text-sm mt-2 font-semibold text-gray-200">Note: Double tap requires two quick, separate taps/key presses on the same side.</p>
                </div>

                <div class="bg-red-900 p-4 rounded-lg border border-red-700">
                    <h3 class="font-semibold text-lg text-red-400 mb-2">Focus Reset:</h3>
                    <p class="space-y-1">
                        Any <span class="font-bold">mistake</span> (wrong side) or failing to tap within the <span class="font-bold">Breath Window</span> will:
                        <ul class="list-disc list-inside ml-4">
                            <li>Reset your streak counter to 0.</li>
                            <li>Play a beep (Mistake Sound for incorrect tap, Focus Reminder for inactivity).</li>
                            <li>Visually highlight the required side.</li>
                        </ul>
                    </p>
                    <p class="text-sm mt-2">
                        Noticing your focus has shifted and gently bringing it back to your breath is an essential part of the meditation. Tap the correct side (or press the correct key) to silence the beep and resume your practice.
                    </p>
                </div>

            </div>

            <button id="close-instructions-btn" class="absolute top-4 right-4 p-2 text-gray-400 hover:text-gray-200 transition duration-150 rounded-full bg-gray-700 hover:bg-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
    </div>

    <!-- Stats Modal Screen (NEW) -->
    <div id="stats-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-gray-900 bg-opacity-80 p-4 transition-opacity duration-300">
        <div class="bg-gray-800 text-gray-100 w-11/12 max-w-4xl p-8 rounded-xl shadow-2xl relative max-h-[90vh] overflow-y-auto transition-colors duration-300">
            <h2 class="text-2xl font-bold mb-6 border-b pb-2 border-gray-700 text-purple-400">Session History</h2>

            <!-- Heatmap Visualization -->
            <div class="mb-8 p-4 bg-gray-900 rounded-lg shadow-inner">
                <h3 class="text-lg font-semibold mb-3 text-gray-300">Last Year's Consistency (Minutes Meditated)</h3>
                <div class="flex space-x-2 mb-2 text-xs text-gray-400 overflow-x-auto pb-2"> <!-- Added overflow scroll for heatmap on very small screens -->
                    <div class="grid grid-rows-7 gap-3 text-center flex-none">
                        <div class="h-3 leading-3">S</div>
                        <div class="h-3"></div>
                        <div class="h-3 leading-3">T</div>
                        <div class="h-3"></div>
                        <div class="h-3 leading-3">T</div>
                        <div class="h-3"></div>
                        <div class="h-3 leading-3">S</div>
                    </div>
                    <div id="heatmap-container" class="flex flex-row flex-wrap flex-1 min-w-[600px]"> <!-- Set min width to ensure grid renders nicely, scrollable container -->
                        <!-- Heatmap cells inserted by JavaScript -->
                    </div>
                </div>
                <div class="flex justify-between items-center mt-4 text-xs text-gray-400">
                    <span>Less Activity</span>
                    <div class="flex items-center space-x-1">
                        <div class="heat-cell !bg-gray-800"></div>
                        <div class="heat-cell level-4"></div>
                        <div class="heat-cell level-3"></div>
                        <div class="heat-cell level-2"></div>
                        <div class="heat-cell level-1"></div>
                        <span>More Activity</span>
                    </div>
                </div>
            </div>

            <h3 class="text-lg font-semibold mb-3 text-gray-300 border-b border-gray-700 pb-2">Session Log</h3>

            <div class="overflow-x-auto">
                <table class="min-w-full table-auto text-sm text-left text-gray-400">
                    <thead class="text-xs text-gray-100 uppercase bg-gray-700">
                        <tr>
                            <th scope="col" class="py-3 px-6 stats-header">Date</th>
                            <th scope="col" class="py-3 px-6 stats-header">Duration</th>
                            <th scope="col" class="py-3 px-6 stats-header">DTN</th>
                            <th scope="col" class="py-3 px-6 stats-header">Hit Rate</th>
                            <th scope="col" class="py-3 px-6 stats-header">Longest Streak</th>
                        </tr>
                    </thead>
                    <tbody id="stats-table-body">
                        <!-- Rows populated by JavaScript -->
                    </tbody>
                </table>
            </div>

            <button id="close-stats-btn" class="absolute top-4 right-4 p-2 text-gray-400 hover:text-gray-200 transition duration-150 rounded-full bg-gray-700 hover:bg-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
    </div>

</body>
</html>