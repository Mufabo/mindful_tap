<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mindful Tap Meditation Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .side-tap-area {
            transition: background-color 0.2s, box-shadow 0.2s;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation; /* Improves responsiveness on touch devices */
        }
        .side-tap-area.expected {
            /* Highlight when the expected side is active */
            box-shadow: 0 0 20px 5px rgba(59, 130, 246, 0.7); /* Blue glow */
        }
        .side-tap-area:active {
            filter: brightness(0.9);
        }
        .beeping-bg {
            animation: pulse-bg 1s infinite alternate;
        }
        @keyframes pulse-bg {
            0% { background-color: #fca5a5; } /* Red-300 */
            100% { background-color: #ef4444; } /* Red-500 */
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen flex flex-col items-center p-4">

    <!-- Header -->
    <header class="w-full max-w-4xl text-center mb-8">
        <h1 class="text-3xl font-bold text-gray-800 mb-2">Mindful Tap: Breath Focus Game</h1>
        <p class="text-sm text-gray-600 mb-4">
            A tool to anchor your mind to your breath. Observe your breath, then tap the required side.
        </p>
    </header>

    <!-- Game Status and Controls -->
    <div class="w-full max-w-4xl bg-white p-6 rounded-lg shadow-xl mb-6 flex flex-col md:flex-row justify-between items-center space-y-4 md:space-y-0">
        <div id="status-display" class="text-lg font-semibold text-gray-700">Status: Idle</div>

        <!-- Central display for Streak and Timer -->
        <div class="text-center space-y-1">
            <div id="session-time-display" class="text-xl font-bold text-gray-800">Session Time: --:--</div>
            <div id="time-remaining-display" class="text-sm text-gray-600">Breath Window: --s</div>
            <div id="streak-display" class="text-2xl font-extrabold text-indigo-600">Streak: 0</div>
            <div id="longest-streak-display" class="text-sm text-gray-500">Longest: 0</div>
        </div>

        <div class="flex space-x-4">
            <button id="guidance-btn" class="px-4 py-3 bg-purple-500 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-purple-600 transition duration-200 transform hover:scale-105">
                ✨ Get Guided Prompt
            </button>
            <button id="settings-btn" class="px-4 py-3 bg-blue-500 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-blue-600 transition duration-200 transform hover:scale-105">
                Settings
            </button>
            <button id="instructions-btn" class="px-4 py-3 bg-gray-500 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-gray-600 transition duration-200 transform hover:scale-105">
                ? Instructions
            </button>
            <button id="stop-btn" class="px-8 py-3 bg-red-600 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-red-700 transition duration-200 transform hover:scale-105" disabled>
                Stop
            </button>
            <button id="start-btn" class="px-8 py-3 bg-green-600 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-green-700 transition duration-200 transform hover:scale-105">
                Start
            </button>
        </div>
    </div>

    <!-- Audio Player (Hidden) -->
    <audio id="audio-player" class="hidden"></audio>

    <!-- Main Tap Area -->
    <main id="game-area" class="w-full max-w-4xl flex flex-col md:flex-row h-96 rounded-xl overflow-hidden shadow-2xl transition duration-500">

        <!-- Left Tap Area -->
        <div id="left-area" class="side-tap-area flex-1 bg-gray-200 flex items-center justify-center p-4 h-1/2 md:h-full border-r md:border-b-0 border-gray-300" data-side="left">
            <div class="text-center">
                <p class="text-3xl font-bold text-gray-800">Left Tap</p>
                <p class="text-xl text-gray-600 mt-1">(Key: F)</p>
            </div>
        </div>

        <!-- Right Tap Area -->
        <div id="right-area" class="side-tap-area flex-1 bg-gray-200 flex items-center justify-center p-4 h-1/2 md:h-full" data-side="right">
            <div class="text-center">
                <p class="text-3xl font-bold text-gray-800">Right Tap</p>
                <p class="text-xl text-gray-600 mt-1">(Key: J)</p>
            </div>
        </div>

    </main>

    <!-- Settings Modal Screen -->
    <div id="settings-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-gray-900 bg-opacity-80 p-4 transition-opacity duration-300">
        <div class="bg-white w-full max-w-md p-8 rounded-xl shadow-2xl relative">
            <h2 class="text-2xl font-bold text-gray-800 mb-6 border-b pb-2">Game Settings</h2>

            <div class="space-y-6">

                <!-- Session Duration Setting -->
                <div class="flex flex-col space-y-2 bg-gray-50 p-4 rounded-lg">
                    <label for="session-duration-input" class="text-gray-700 font-medium text-lg">Session Duration:</label>
                    <div class="flex items-center space-x-2">
                         <input id="session-duration-input" type="number" value="10" min="1" max="180" class="w-full p-2 border border-gray-300 rounded-md text-center text-lg focus:ring-blue-500 focus:border-blue-500" disabled>
                         <span class="text-gray-600 font-medium">minutes</span>
                    </div>
                    <p class="text-sm text-gray-500">The total time the meditation will run (1-180 min).</p>
                </div>

                <!-- Focus Window Duration Setting -->
                <div class="flex flex-col space-y-2 bg-gray-50 p-4 rounded-lg">
                    <label for="duration-input" class="text-gray-700 font-medium text-lg">Focus Window Duration:</label>
                    <div class="flex items-center space-x-2">
                         <input id="duration-input" type="number" value="30" min="5" max="180" class="w-full p-2 border border-gray-300 rounded-md text-center text-lg focus:ring-blue-500 focus:border-blue-500" disabled>
                         <span class="text-gray-600 font-medium">seconds</span>
                    </div>
                    <p class="text-sm text-gray-500">Time (in seconds) allowed between taps before focus reset.</p>
                </div>

                <!-- DTN Setting -->
                <div class="flex flex-col space-y-2 bg-gray-50 p-4 rounded-lg">
                    <label for="dtn-input" class="text-gray-700 font-medium text-lg">Double Tap Number (DTN):</label>
                    <input id="dtn-input" type="number" value="5" min="2" class="w-full p-2 border border-gray-300 rounded-md text-center text-lg focus:ring-blue-500 focus:border-blue-500" disabled>
                    <p class="text-sm text-gray-500">How many breaths before a simultaneous tap is required.</p>
                </div>

                <!-- Hide Status Setting -->
                <div class="flex flex-col space-y-2 bg-gray-50 p-4 rounded-lg">
                    <label for="hide-status-input" class="text-gray-700 font-medium text-lg flex items-center justify-between">
                        Hide Status Display
                        <input id="hide-status-input" type="checkbox" class="h-6 w-6 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                    </label>
                    <p class="text-sm text-gray-500">Hide the detailed "Status" line during meditation for a cleaner view.</p>
                </div>

            </div>

            <button id="save-settings-btn" class="mt-6 w-full px-4 py-3 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
                Save All Settings
            </button>


            <button id="close-settings-btn" class="absolute top-4 right-4 p-2 text-gray-600 hover:text-gray-800 transition duration-150 rounded-full bg-gray-100 hover:bg-gray-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
    </div>

    <!-- Instructions Modal Screen -->
    <div id="instructions-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-gray-900 bg-opacity-80 p-4 transition-opacity duration-300">
        <div class="bg-white w-full max-w-3xl p-8 rounded-xl shadow-2xl relative max-h-[90vh] overflow-y-auto">
            <h2 class="text-3xl font-bold text-gray-800 mb-6 border-b pb-2">Mindful Tap Instructions</h2>

            <div class="text-gray-700 text-base space-y-4">
                <p>Before starting, take a comfortable position. You may close your eyes if you wish.</p>

                <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                    <h3 class="font-semibold text-lg text-blue-700 mb-2">The Basic Rhythm:</h3>
                    <p class="mb-2">Observe your complete breath cycle (in-breath and out-breath).</p>
                    <ul class="list-disc list-inside space-y-1 ml-4">
                        <li>After each completed breath, tap the screen or press a key.</li>
                        <li>The required tap site alternates: <span class="font-bold text-gray-900">Right (J key)</span> then <span class="font-bold text-gray-900">Left (F key)</span>.</li>
                        <li>The meditation starts with a tap on the <span class="font-bold text-blue-600">Right side</span>.</li>
                    </ul>
                </div>

                <div class="bg-yellow-50 p-4 rounded-lg border border-yellow-200">
                    <h3 class="font-semibold text-lg text-yellow-700 mb-2">Simultaneous Tap Cycle (DTN):</h3>
                    <p>On every DTN-th breath (currently set to <span id="modal-dtn-display" class="font-bold text-red-600">5</span>), you must perform a <span class="font-bold text-red-600">SIMULTANEOUS KEY PRESS (F + J)</span>.</p>
                    <p class="text-sm italic mt-1">Example (DTN=5): B1 (Right, single), B2 (Left, single), B3 (Right, single), B4 (Left, single), B5 (<span class="font-bold text-red-600">F + J simultaneously</span>). Then, restart counting (B1) with the opposite side (Left).</p>
                    <p class="text-sm mt-2 font-semibold text-gray-800">Note: Simultaneous tap is only supported using the keyboard (F and J keys).</p>
                </div>

                <div class="bg-red-50 p-4 rounded-lg border border-red-200">
                    <h3 class="font-semibold text-lg text-red-700 mb-2">Focus Reset:</h3>
                    <p class="space-y-1">
                        Any <span class="font-bold">mistake</span> (wrong side, wrong tap type, or failure to press F+J) or failing to tap within the <span class="font-bold">Breath Window</span> will:
                        <ul class="list-disc list-inside ml-4">
                            <li>Reset your streak counter to 0.</li>
                            <li>Play a beep (Mistake Sound for alternating taps, Focus Reminder for inactivity).</li>
                            <li>Visually highlight the required side(s).</li>
                        </ul>
                    </p>
                    <p class="text-sm mt-2">
                        <span class="font-bold text-gray-800">Note:</span> The mistake sound is suppressed during the DTN simultaneous tap attempt to maintain focus on coordination. Noticing your focus has shifted and gently bringing it back to your breath is an essential part of the meditation. Tap the correct side (or press the correct key combination) to silence the beep and resume your practice.
                    </p>
                </div>

            </div>

            <button id="close-instructions-btn" class="absolute top-4 right-4 p-2 text-gray-600 hover:text-gray-800 transition duration-150 rounded-full bg-gray-100 hover:bg-gray-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
    </div>

    <!-- Focus Analysis Modal (NEW) -->
    <div id="analysis-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-gray-900 bg-opacity-80 p-4 transition-opacity duration-300">
        <div class="bg-white w-full max-w-lg p-8 rounded-xl shadow-2xl relative">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                <span class="text-purple-600 mr-2">✨</span> Session Focus Analysis
            </h2>
            <div id="analysis-content" class="text-gray-700 text-base space-y-3">
                <!-- Analysis content generated here -->
                <p>Analyzing session...</p>
            </div>
            <button id="close-analysis-btn" class="mt-6 w-full px-4 py-3 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
                Close
            </button>
        </div>
    </div>


    <!-- User ID Display for Collaboration -->
    <footer class="mt-8 text-sm text-gray-500 w-full max-w-4xl text-center">
        Your User ID (for data storage): <span id="user-id-display" class="font-mono text-gray-700">Loading...</span>
    </footer>

    <script type="module">
        // --- Gemini API Setup ---
        const API_KEY = ""; // Canvas provides the key at runtime
        const TEXT_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;
        const TTS_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${API_KEY}`;

        // --- Firebase Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Game Constants and State ---
        const DTN_DEFAULT = 5;
        const DEFAULT_INACTIVITY_MS = 30000; // 30 seconds default
        const SESSION_DURATION_DEFAULT_MINUTES = 10;
        const DOUBLE_TAP_WINDOW_MS = 300;

        const state = {
            dtn: DTN_DEFAULT,
            inactivityDurationMs: DEFAULT_INACTIVITY_MS,
            sessionDurationMinutes: SESSION_DURATION_DEFAULT_MINUTES,
            hideStatus: false,
            gameState: 'idle', // 'idle', 'running', 'paused', 'complete'
            breathCount: 0, // 1 to DTN
            currentStreak: 0,
            longestStreak: 0,
            expectedSide: 'right', // 'left', 'right', or 'both' (for simultaneous tap)
            expectedTapType: 'single', // 'single', or 'simultaneous' (DTN-th tap)
            cycleStartSide: 'right', // The side the current cycle started on (B1)
            tapTimer: null, // Timer for the focus window (inactivity reset)
            isBeeping: false,
            // For screen double tap detection
            lastTapTime: 0,
            tapSide: null,
            tapTimeout: null,
            // Timers for display and session management
            timeRemaining: DEFAULT_INACTIVITY_MS / 1000, // Breath window seconds remaining
            countdownInterval: null, // Interval for the breath window countdown
            sessionTimer: null, // Timeout for total session duration
            sessionTimeRemainingSeconds: 0,
            sessionCountdownInterval: null, // Interval for the session countdown
        };

        // --- Keyboard State for Simultaneous Press ---
        let fDown = false;
        let jDown = false;


        // --- Firebase/Auth Setup ---
        let db, auth;
        let userId = 'loading';
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        const DTN_DOC_PATH = (uid) => `artifacts/${appId}/users/${uid}/meditation_game/settings`;

        async function initializeFirebase() {
            if (!firebaseConfig) {
                console.error("Firebase config is missing. Data persistence disabled.");
                // Use a fake Firestore interface to prevent crashes
                db = {
                    getDTNDocRef: () => ({ id: 'mock' }),
                    setDTN: async () => {},
                    saveDTN: async () => {},
                    getDoc: async () => ({ exists: () => false }),
                    setDoc: async () => {},
                    onSnapshot: () => (() => {}), // Return an empty unsubscribe function
                };
                return;
            }

            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        document.getElementById('user-id-display').textContent = userId;
                        setupFirestoreListener(userId);
                    } else {
                        // This case should ideally not happen if signed in anonymously/custom token
                        console.log("User signed out or failed to sign in.");
                        document.getElementById('user-id-display').textContent = 'Error/No Auth';
                    }
                });

            } catch (error) {
                console.error("Firebase initialization or sign-in failed:", error);
                document.getElementById('user-id-display').textContent = 'Error';
            }
        }

        // --- Firestore Data Persistence ---

        function setupFirestoreListener(uid) {
            const docRef = doc(db, DTN_DOC_PATH(uid));
            onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    state.dtn = data.dtn || DTN_DEFAULT;
                    state.inactivityDurationMs = data.inactivityDurationMs || DEFAULT_INACTIVITY_MS;
                    state.sessionDurationMinutes = data.sessionDurationMinutes || SESSION_DURATION_DEFAULT_MINUTES;
                    state.longestStreak = data.longestStreak || 0;
                    state.hideStatus = data.hideStatus !== undefined ? data.hideStatus : false; // Load new setting

                    // Update input values only when loading from Firestore
                    document.getElementById('dtn-input').value = state.dtn;
                    document.getElementById('duration-input').value = state.inactivityDurationMs / 1000;
                    document.getElementById('session-duration-input').value = state.sessionDurationMinutes;
                    document.getElementById('hide-status-input').checked = state.hideStatus;

                    updateUI();
                } else {
                    // Initialize with default values if document does not exist
                    saveSettings(DTN_DEFAULT, DEFAULT_INACTIVITY_MS, SESSION_DURATION_DEFAULT_MINUTES, 0, false);
                }
            }, (error) => {
                console.error("Error setting up Firestore listener:", error);
            });
        }

        async function saveSettings(dtn, inactivityDurationMs, sessionDurationMinutes, longestStreak, hideStatus) {
            if (userId === 'loading' || !db) return;
            try {
                const docRef = doc(db, DTN_DOC_PATH(userId));
                await setDoc(docRef, {
                    dtn: dtn,
                    inactivityDurationMs: inactivityDurationMs,
                    sessionDurationMinutes: sessionDurationMinutes,
                    longestStreak: longestStreak,
                    hideStatus: hideStatus, // Save new setting
                }, { merge: true });
            } catch (error) {
                console.error("Error saving settings:", error);
            }
        }

        // --- Audio Context for Focus Reminder (Beep) ---
        let audioContext;
        let oscillator;
        let gainNode;

        function startBeeping() {
            if (state.isBeeping) return;
            state.isBeeping = true;

            try {
                audioContext = audioContext || new (window.AudioContext || window.webkitAudioContext)();
                oscillator = audioContext.createOscillator();
                gainNode = audioContext.createGain();

                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4 note
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Start beeping pattern (simple on/off)
                const beepDuration = 0.2; // seconds
                const interval = 0.5; // seconds

                let time = audioContext.currentTime;

                // Create the repeating pattern
                for (let i = 0; i < 20; i++) { // Repeat 20 times, enough to get focus back
                    gainNode.gain.setValueAtTime(0.5, time + i * interval);
                    gainNode.gain.setValueAtTime(0, time + i * interval + beepDuration);
                }

                oscillator.start(time);
                oscillator.stop(time + 20 * interval);

                oscillator.onended = () => {
                    if (state.isBeeping) {
                        // Restart beeping if still required
                        startBeeping();
                    }
                };

            } catch (e) {
                console.warn("Audio API not supported or failed to start:", e);
            }
        }

        function stopBeeping() {
            if (!state.isBeeping) return;
            state.isBeeping = false;
            if (oscillator) {
                try {
                    // Smoothly fade out the gain to avoid click sound
                    gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.1);
                    oscillator.stop(audioContext.currentTime + 0.1);
                } catch (e) {
                    console.error("Error stopping audio:", e);
                }
            }
        }

        function playMistakeTone() {
            try {
                audioContext = audioContext || new (window.AudioContext || window.webkitAudioContext)();
                const tone = audioContext.createOscillator();
                const gain = audioContext.createGain();

                tone.type = 'sawtooth';
                tone.frequency.setValueAtTime(120, audioContext.currentTime); // Low frequency tone
                gain.gain.setValueAtTime(0.3, audioContext.currentTime); // Volume

                tone.connect(gain);
                gain.connect(audioContext.destination);

                tone.start(audioContext.currentTime);
                tone.stop(audioContext.currentTime + 0.15); // Short duration (150ms)

            } catch (e) {
                console.warn("Audio API not supported or failed to play mistake tone:", e);
            }
        }

        // --- Utility Functions ---

        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const paddedSeconds = String(seconds).padStart(2, '0');
            return `${minutes}:${paddedSeconds}`;
        }

        // Function to convert Base64 string to ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Function to convert PCM audio data (Int16Array) to WAV Blob
        function pcmToWav(pcm16, sampleRate) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);

            const buffer = new ArrayBuffer(44 + pcm16.length * 2);
            const view = new DataView(buffer);

            // RIFF identifier
            writeString(view, 0, 'RIFF');
            // File length
            view.setUint32(4, 36 + pcm16.length * 2, true);
            // WAVE identifier
            writeString(view, 8, 'WAVE');
            // fmt sub-chunk identifier
            writeString(view, 12, 'fmt ');
            // fmt sub-chunk length
            view.setUint32(16, 16, true);
            // Audio format (1 for PCM)
            view.setUint16(20, 1, true);
            // Number of channels
            view.setUint16(22, numChannels, true);
            // Sample rate
            view.setUint32(24, sampleRate, true);
            // Byte rate
            view.setUint32(28, byteRate, true);
            // Block align
            view.setUint16(32, blockAlign, true);
            // Bits per sample
            view.setUint16(34, bitsPerSample, true);
            // data sub-chunk identifier
            writeString(view, 36, 'data');
            // data sub-chunk length
            view.setUint32(40, pcm16.length * 2, true);

            // Write PCM data
            let offset = 44;
            for (let i = 0; i < pcm16.length; i++, offset += 2) {
                view.setInt16(offset, pcm16[i], true);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }


        // --- Game Logic Functions ---

        function updateUI(statusOverride = null) {
            const leftArea = document.getElementById('left-area');
            const rightArea = document.getElementById('right-area');
            const statusDisplay = document.getElementById('status-display');
            const streakDisplay = document.getElementById('streak-display');
            const longestStreakDisplay = document.getElementById('longest-streak-display');
            const startBtn = document.getElementById('start-btn');
            const stopBtn = document.getElementById('stop-btn');
            const guidanceBtn = document.getElementById('guidance-btn');
            const modalDtnDisplay = document.getElementById('modal-dtn-display');
            const dtnInput = document.getElementById('dtn-input');
            const durationInput = document.getElementById('duration-input');
            const sessionDurationInput = document.getElementById('session-duration-input');
            const hideStatusInput = document.getElementById('hide-status-input');
            const timeRemainingDisplay = document.getElementById('time-remaining-display');
            const sessionTimeDisplay = document.getElementById('session-time-display');

            // 1. Game State and Buttons
            let currentStatus = `Status: ${state.gameState.toUpperCase()}`;
            if (statusOverride === 'complete') {
                currentStatus = '<span class="text-green-600 font-bold">Session Complete!</span>';
            }

            const isGameActive = state.gameState === 'running' || state.gameState === 'paused';

            // Apply visibility setting: Hide only when active AND setting is enabled
            if (state.hideStatus && isGameActive) {
                statusDisplay.classList.add('hidden');
            } else {
                statusDisplay.classList.remove('hidden');
                statusDisplay.innerHTML = currentStatus; // Set the generic status if not hidden
            }

            startBtn.disabled = isGameActive;
            stopBtn.disabled = !isGameActive;
            guidanceBtn.disabled = isGameActive; // Disable guidance once the game starts

            if (isGameActive) {
                startBtn.textContent = 'Running...';
            } else if (state.gameState === 'idle') {
                startBtn.textContent = 'Start';
            }

            // 2. Tap Area Highlight
            leftArea.classList.remove('expected');
            rightArea.classList.remove('expected');

            if (isGameActive) {
                let tapText;
                if (state.expectedTapType === 'simultaneous') {
                     // Highlight both sides for simultaneous tap
                     leftArea.classList.add('expected');
                     rightArea.classList.add('expected');
                     tapText = 'SIMULTANEOUS (F + J)';

                     if (!state.hideStatus) {
                         statusDisplay.innerHTML = `Breath ${state.breathCount}/${state.dtn} | <span class="text-red-600 font-bold">${tapText}</span>`;
                     }
                } else {
                    // Highlight single expected side
                    const expectedArea = document.getElementById(`${state.expectedSide}-area`);
                    expectedArea.classList.add('expected');
                    tapText = 'Single Tap';

                    if (!state.hideStatus) {
                        statusDisplay.innerHTML = `Breath ${state.breathCount}/${state.dtn} | <span class="text-blue-600">${state.expectedSide.toUpperCase()} (${tapText})</span>`;
                    }
                }
            }

            // 3. Beeping/Focus Reset Visual
            const gameArea = document.getElementById('game-area');
            gameArea.classList.toggle('beeping-bg', state.isBeeping);

            // 4. Streaks
            streakDisplay.textContent = `Streak: ${state.currentStreak}`;
            longestStreakDisplay.textContent = `Longest: ${state.longestStreak}`;

            // 5. Timer Displays
            if (isGameActive) {
                timeRemainingDisplay.textContent = `Breath Window: ${Math.max(0, state.timeRemaining)}s`;
                sessionTimeDisplay.textContent = `Session Time: ${formatTime(state.sessionTimeRemainingSeconds)}`;
            } else {
                timeRemainingDisplay.textContent = 'Breath Window: --s';
                sessionTimeDisplay.textContent = 'Session Time: --:--';
            }

            // 6. Modal Input Updates (ensure inputs reflect current state/saved values)
            if (document.getElementById('settings-modal').classList.contains('hidden')) {
                dtnInput.value = state.dtn;
                dtnInput.disabled = true;
                durationInput.value = state.inactivityDurationMs / 1000;
                durationInput.disabled = true;
                sessionDurationInput.value = state.sessionDurationMinutes;
                sessionDurationInput.disabled = true;
                hideStatusInput.checked = state.hideStatus;
            }
            if (modalDtnDisplay) {
                modalDtnDisplay.textContent = state.dtn;
            }
        }

        // Stops the session, resets all timers, and transitions to idle/complete state.
        function stopMeditation(trigger = 'manual') {
            stopBeeping();

            // Clear all timers
            clearTimeout(state.tapTimer);
            clearInterval(state.countdownInterval);
            clearTimeout(state.sessionTimer);
            clearInterval(state.sessionCountdownInterval);

            state.tapTimer = null;
            state.countdownInterval = null;
            state.sessionTimer = null;
            state.sessionCountdownInterval = null;

            const finalStreak = state.currentStreak;

            // Save streak if it's a record
            if (finalStreak > state.longestStreak) {
                state.longestStreak = finalStreak;
                saveSettings(state.dtn, state.inactivityDurationMs, state.sessionDurationMinutes, state.longestStreak, state.hideStatus);
            }

            // Reset streak and breath tracking
            state.currentStreak = 0;
            state.breathCount = 0; // Ensures restart goes to B1
            state.expectedSide = 'right';
            state.expectedTapType = 'single';
            state.cycleStartSide = 'right';

            // Set final game state and update UI
            state.gameState = 'idle';
            updateUI(trigger === 'complete' ? 'complete' : null);

            // If a session ended (manual or complete), generate and show analysis
            if (trigger === 'manual' || trigger === 'complete') {
                generateFocusAnalysis(finalStreak, state.sessionDurationMinutes, state.longestStreak, state.dtn);
            }
        }

        /**
         * Resets the breath counter/streak due to mistake or inactivity, but keeps session running.
         * @param {('mistake'|'tap_mistake'|'inactivity'|'start')} trigger - Type of reset.
         * 'mistake': input error on alternating tap, plays tone.
         * 'tap_mistake': input error on simultaneous tap, suppresses tone.
         * 'inactivity': timeout, starts beeping.
         * 'start': manual start, no sound.
         */
        function resetFocus(trigger) {
            console.log(`Resetting focus due to: ${trigger}`);

            // Play mistake tone if reset was due to an input error on alternating tap
            if (trigger === 'mistake') {
                playMistakeTone();
            }

            // Save current streak if it's the longest
            if (state.currentStreak > state.longestStreak) {
                state.longestStreak = state.currentStreak;
                saveSettings(state.dtn, state.inactivityDurationMs, state.sessionDurationMinutes, state.longestStreak, state.hideStatus);
            }

            // Reset breath/streak counters
            state.currentStreak = 0;
            state.breathCount = 1;
            state.cycleStartSide = 'right';
            state.expectedSide = 'right';
            state.expectedTapType = (state.dtn === 1) ? 'simultaneous' : 'single'; // Handle DTN=1 case on reset

            if (trigger === 'inactivity') {
                state.gameState = 'paused';
                startBeeping();
            } else { // Handles 'mistake', 'tap_mistake', and 'start'
                state.gameState = 'running';
                startTapTimer();
            }

            updateUI();
        }

        // Starts or restarts the breath focus timer (inactivity reset)
        function startTapTimer() {
            clearTimeout(state.tapTimer);
            clearInterval(state.countdownInterval);

            // 1. Start the inactivity timer using the user-defined duration
            state.tapTimer = setTimeout(() => {
                resetFocus('inactivity');
            }, state.inactivityDurationMs);

            // 2. Start the countdown display
            const durationInSeconds = state.inactivityDurationMs / 1000;
            state.timeRemaining = durationInSeconds;

            state.countdownInterval = setInterval(() => {
                state.timeRemaining = Math.max(0, state.timeRemaining - 1);
                updateUI();

                if (state.timeRemaining <= 0) {
                    clearInterval(state.countdownInterval);
                    state.countdownInterval = null;
                }
            }, 1000);

            updateUI();
        }

        // Starts the main session duration timer
        function startSessionTimer() {
            clearTimeout(state.sessionTimer);
            clearInterval(state.sessionCountdownInterval);

            const durationMs = state.sessionDurationMinutes * 60 * 1000;

            // Set up the main timer that stops the session
            state.sessionTimer = setTimeout(() => {
                stopMeditation('complete');
            }, durationMs);

            // Set up the display countdown
            state.sessionTimeRemainingSeconds = state.sessionDurationMinutes * 60;
            state.sessionCountdownInterval = setInterval(() => {
                state.sessionTimeRemainingSeconds = Math.max(0, state.sessionTimeRemainingSeconds - 1);
                updateUI();
                if (state.sessionTimeRemainingSeconds <= 0) {
                    clearInterval(state.sessionCountdownInterval);
                    state.sessionCountdownInterval = null;
                }
            }, 1000);
        }

        function advanceBreath() {
            state.currentStreak++;

            if (state.breathCount === state.dtn) {
                // Cycle complete! (Just processed the simultaneous tap). Prepare for the NEXT cycle (B1).
                state.breathCount = 1;
                state.cycleStartSide = (state.cycleStartSide === 'right' ? 'left' : 'right');
                state.expectedSide = state.cycleStartSide;
                state.expectedTapType = (state.dtn === 1) ? 'simultaneous' : 'single';
            } else {
                // Advance within the cycle. Prepare for the NEXT breath (B_n+1).
                state.breathCount++;
                state.expectedSide = (state.expectedSide === 'right' ? 'left' : 'right');

                if (state.breathCount === state.dtn) {
                     // The NEXT tap must be simultaneous (DTN-th breath)
                     state.expectedSide = 'both';
                     state.expectedTapType = 'simultaneous';
                } else {
                     // The NEXT tap must be single
                     state.expectedTapType = 'single';
                }
            }

            // Successfully processed, restart breath window timer
            startTapTimer();
        }

        function handleTap(actualSide, actualTapType) {
            // Prevent interaction if modals are open or game is idle/complete
            if (document.getElementById('instructions-modal').classList.contains('hidden') === false ||
                document.getElementById('settings-modal').classList.contains('hidden') === false ||
                document.getElementById('analysis-modal').classList.contains('hidden') === false) {
                return;
            }
            if (state.gameState !== 'running' && state.gameState !== 'paused') return;

            // If in "paused" (beeping) state, only accept correct tap to resume
            if (state.isBeeping) {
                if (actualSide === state.expectedSide && actualTapType === state.expectedTapType) {
                    // Correct tap while beeping, resume game flow
                    stopBeeping();
                    state.gameState = 'running';
                    advanceBreath();
                } else {
                    // Wrong tap while beeping - still a mistake, but keeps beeping
                    console.log("Mistake while Beeping - try again.");
                }
                return;
            }

            // Normal game flow
            const success = (
                actualSide === state.expectedSide &&
                actualTapType === state.expectedTapType
            );

            if (success) {
                advanceBreath();
            } else {
                // MISTAKE detected.

                // If the expected tap was simultaneous (DTN-th breath), reset but suppress the mistake tone ('tap_mistake').
                // Otherwise, it's a regular alternating tap mistake ('mistake') and the tone should play.
                const mistakeTrigger = state.expectedTapType === 'simultaneous' ? 'tap_mistake' : 'mistake';
                resetFocus(mistakeTrigger);
            }
        }

        // --- Gemini API Functions ---

        async function fetchWithRetry(url, payload, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        return await response.json();
                    }

                    if (response.status === 429 && i < retries - 1) {
                        const delay = Math.pow(2, i) * 1000;
                        console.warn(`Rate limit hit. Retrying in ${delay / 1000}s...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    throw new Error(`API request failed with status: ${response.status}`);

                } catch (error) {
                    console.error("API fetch error:", error);
                    if (i === retries - 1) throw error;
                    const delay = Math.pow(2, i) * 1000;
                    console.warn(`Request failed. Retrying in ${delay / 1000}s...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        async function generateAndPlayGuidance() {
            const guidanceBtn = document.getElementById('guidance-btn');
            const originalText = guidanceBtn.textContent;
            const audioPlayer = document.getElementById('audio-player');

            guidanceBtn.textContent = 'Generating...';
            guidanceBtn.disabled = true;
            audioPlayer.pause();
            audioPlayer.removeAttribute('src');

            const userPrompt = `Generate a very short, soothing, and encouraging guided meditation prompt (about 15-20 words). The theme should be focusing on the present moment and returning attention to the breath. Do not include a speaker name.`;

            const payload = {
                contents: [{
                    parts: [{ text: userPrompt }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Achird" } // Friendly voice
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            try {
                const result = await fetchWithRetry(TTS_API_URL, payload);
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    const match = mimeType.match(/rate=(\d+)/);
                    const sampleRate = match ? parseInt(match[1], 10) : 16000; // Default if rate not found

                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);

                    audioPlayer.src = audioUrl;
                    audioPlayer.play();

                    guidanceBtn.textContent = 'Playing Guidance...';
                    audioPlayer.onended = () => {
                        guidanceBtn.textContent = originalText;
                        guidanceBtn.disabled = false;
                        URL.revokeObjectURL(audioUrl);
                    };

                } else {
                    throw new Error("Invalid audio response structure from TTS API.");
                }

            } catch (e) {
                console.error("Gemini TTS Error:", e);
                guidanceBtn.textContent = 'TTS Failed';
                setTimeout(() => { guidanceBtn.textContent = originalText; guidanceBtn.disabled = false; }, 3000);
            }
        }

        async function generateFocusAnalysis(finalStreak, sessionDuration, longestStreak, dtn) {
            const analysisModal = document.getElementById('analysis-modal');
            const analysisContent = document.getElementById('analysis-content');

            analysisContent.innerHTML = '<p class="text-center py-4">Analyzing your focus patterns...<span class="animate-pulse">.</span><span class="animate-pulse" style="animation-delay: 0.1s;">.</span><span class="animate-pulse" style="animation-delay: 0.2s;">.</span></p>';
            analysisModal.classList.remove('hidden');

            const userPrompt = `You are a mindful meditation coach. The user just completed a ${sessionDuration} minute focus session. Their best streak in this session was ${finalStreak} breaths. Their all-time longest streak is ${longestStreak} breaths, and they reset their sequence every ${dtn} breaths. Provide a concise (2-3 sentences), encouraging, and gentle analysis of their focus, acknowledging their effort and suggesting a single positive takeaway for their next session. Do not use markdown formatting (like **).`;

            const payload = {
                contents: [{ parts: [{ text: userPrompt }] }],
                systemInstruction: {
                    parts: [{ text: "Act as a compassionate and encouraging meditation coach. Keep the response short, positive, and insightful." }]
                },
            };

            try {
                const result = await fetchWithRetry(TEXT_API_URL, payload);
                const text = result?.candidates?.[0]?.content?.parts?.[0]?.text || "We couldn't generate the analysis right now, but great effort today! Every breath counts.";

                analysisContent.innerHTML = `<p>${text}</p>`;

            } catch (e) {
                console.error("Gemini Analysis Error:", e);
                analysisContent.innerHTML = '<p class="text-red-600">Focus Analysis failed to load. Please try again later. But remember, every moment of awareness is a success!</p>';
            }
        }


        // --- Event Handlers ---

        // 1. Screen Tap Logic (Only works for single taps. Disabled during simultaneous breath.)
        function handleScreenTap(event) {
            if (state.expectedTapType === 'simultaneous') {
                 // Ignore click/touch when expecting simultaneous keyboard input
                 return;
            }

            const target = event.currentTarget;
            const actualSide = target.dataset.side;
            const currentTime = Date.now();

            if (state.tapTimeout === null) {
                // First tap: record time and side, set a timeout
                state.lastTapTime = currentTime;
                state.tapSide = actualSide;

                state.tapTimeout = setTimeout(() => {
                    // Timeout hit: assume this was a single tap
                    state.tapTimeout = null;
                    if (state.tapSide === actualSide) {
                         handleTap(actualSide, 'single');
                    }
                }, DOUBLE_TAP_WINDOW_MS);

            } else if (actualSide === state.tapSide && (currentTime - state.lastTapTime) < DOUBLE_TAP_WINDOW_MS) {
                // Second tap within window on the same side: detected double tap (MISTAKE now)
                clearTimeout(state.tapTimeout);
                state.tapTimeout = null;
                // Double tap is now always a mistake during single tap sequence
                handleTap(actualSide, 'double');
            } else {
                // Tap on a different side or outside the time window: treat as mistake and restart single tap detection
                clearTimeout(state.tapTimeout);
                state.tapTimeout = null;
                // Treat this as the first tap of a potential new sequence
                handleScreenTap(event);
            }
        }

        // Set up key up handler to reset flags
        document.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            if (key === 'f') fDown = false;
            if (key === 'j') jDown = false;
        });

        // 2. Keyboard Logic (F for left, J for right, F+J for simultaneous)
        function handleKeyDown(event) {
            const key = event.key.toLowerCase();
            let actualSide = null;

            if (key === 'f') {
                actualSide = 'left';
                fDown = true;
            } else if (key === 'j') {
                actualSide = 'right';
                jDown = true;
            } else {
                return;
            }

            // Prevent holding the key down from triggering continuous taps
            if (event.repeat) return;

            if (state.gameState !== 'running' && state.gameState !== 'paused') return;

            // 1. Check for SIMULTANEOUS TAP (F+J)
            if (state.expectedTapType === 'simultaneous' && fDown && jDown) {
                handleTap('both', 'simultaneous');
                // Reset flags after a successful simultaneous tap is detected and handled
                fDown = false;
                jDown = false;
                return;
            }

            // 2. Normal single tap sequence check
            if (state.expectedTapType === 'single') {
                 // Single tap always expected here
                 handleTap(actualSide, 'single');
            } else {
                 // MISTAKE: Single key pressed when simultaneous was expected
                 if (state.expectedTapType === 'simultaneous' && (fDown || jDown)) {
                      handleTap(actualSide, 'single'); // This will fail inside handleTap and trigger resetFocus('tap_mistake')
                 }
            }
        }

        // 3. Button and Input Handlers

        document.getElementById('start-btn').addEventListener('click', () => {
            if (state.gameState === 'idle' || state.gameState === 'complete') {
                // Start a fresh meditation session
                startSessionTimer(); // Start the overall session timer
                resetFocus('start'); // Start the breath tracking
            }
        });

        document.getElementById('stop-btn').addEventListener('click', () => stopMeditation('manual'));

        document.getElementById('guidance-btn').addEventListener('click', generateAndPlayGuidance);

        document.getElementById('save-settings-btn').addEventListener('click', () => {
            const dtnInput = document.getElementById('dtn-input');
            const durationInput = document.getElementById('duration-input');
            const sessionDurationInput = document.getElementById('session-duration-input');
            const hideStatusInput = document.getElementById('hide-status-input');

            const newDTN = parseInt(dtnInput.value, 10);
            const newDurationSec = parseInt(durationInput.value, 10);
            const newDurationMs = newDurationSec * 1000;
            const newSessionDurationMin = parseInt(sessionDurationInput.value, 10);
            const newHideStatus = hideStatusInput.checked;

            let isValid = true;
            let feedback = '';

            if (newDTN < 2) {
                feedback += "DTN must be 2 or greater. ";
                dtnInput.value = state.dtn;
                isValid = false;
            }
            if (newDurationSec < 5 || newDurationSec > 180) {
                 feedback += "Breath Window Duration must be between 5 and 180 seconds. ";
                 durationInput.value = state.inactivityDurationMs / 1000;
                 isValid = false;
            }
            if (newSessionDurationMin < 1 || newSessionDurationMin > 180) {
                 feedback += "Session Duration must be between 1 and 180 minutes. ";
                 sessionDurationInput.value = state.sessionDurationMinutes;
                 isValid = false;
            }

            if (isValid) {
                state.dtn = newDTN;
                state.inactivityDurationMs = newDurationMs;
                state.sessionDurationMinutes = newSessionDurationMin; // Set new session duration
                state.hideStatus = newHideStatus;

                saveSettings(state.dtn, state.inactivityDurationMs, state.sessionDurationMinutes, state.longestStreak, state.hideStatus);

                dtnInput.disabled = true;
                durationInput.disabled = true;
                sessionDurationInput.disabled = true;

                // Show confirmation message
                const originalText = document.getElementById('save-settings-btn').textContent;
                document.getElementById('save-settings-btn').textContent = 'Saved!';
                setTimeout(() => {
                    document.getElementById('save-settings-btn').textContent = originalText;
                    closeSettings(); // Close modal after saving
                }, 1000);

                // If game is running, restart breath timer with new duration, but session timer continues unless reset.
                if (state.gameState === 'running' || state.gameState === 'paused') {
                    startTapTimer();
                }

            } else {
                console.error("Settings validation failed:", feedback);
            }
        });

        // Toggle input editability
        document.getElementById('dtn-input').addEventListener('click', () => {
             document.getElementById('dtn-input').disabled = false;
        });
        document.getElementById('duration-input').addEventListener('click', () => {
             document.getElementById('duration-input').disabled = false;
        });
        document.getElementById('session-duration-input').addEventListener('click', () => {
             document.getElementById('session-duration-input').disabled = false;
        });

        // 4. Modal Handlers
        function openInstructions() {
            document.getElementById('instructions-modal').classList.remove('hidden');
        }

        function closeInstructions() {
            document.getElementById('instructions-modal').classList.add('hidden');
        }

        function openSettings() {
             // Ensure the inputs reflect the current state before opening
            document.getElementById('dtn-input').value = state.dtn;
            document.getElementById('duration-input').value = state.inactivityDurationMs / 1000;
            document.getElementById('session-duration-input').value = state.sessionDurationMinutes;
            document.getElementById('hide-status-input').checked = state.hideStatus;

            document.getElementById('dtn-input').disabled = true;
            document.getElementById('duration-input').disabled = true;
            document.getElementById('session-duration-input').disabled = true;
            document.getElementById('settings-modal').classList.remove('hidden');
        }

        function closeSettings() {
            document.getElementById('settings-modal').classList.add('hidden');
            // Re-run UI update to ensure values are correctly reflected
            updateUI();
        }

        function closeAnalysis() {
            document.getElementById('analysis-modal').classList.add('hidden');
        }
        document.getElementById('close-analysis-btn').addEventListener('click', closeAnalysis);


        // --- Initialization ---

        window.onload = async function() {
            await initializeFirebase();

            // Add event listeners for tap areas
            document.getElementById('left-area').addEventListener('click', handleScreenTap);
            document.getElementById('right-area').addEventListener('click', handleScreenTap);

            // Add event listeners for keyboard input
            document.addEventListener('keydown', handleKeyDown);

            // Add event listeners for modal buttons
            document.getElementById('instructions-btn').addEventListener('click', openInstructions);
            document.getElementById('close-instructions-btn').addEventListener('click', closeInstructions);
            document.getElementById('settings-btn').addEventListener('click', openSettings);
            document.getElementById('close-settings-btn').addEventListener('click', closeSettings);

            // Initial UI setup
            updateUI();
        };

    </script>
</body>
</html>